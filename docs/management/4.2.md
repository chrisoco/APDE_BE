# 4.2 Server App

## Aufgabe 1: Serverseitige Basis Applikation

### ðŸŽ¯ Ziel
Implementierung einer **Laravel 12-basierten Server-Applikation** gemÃ¤ss dem gewÃ¤hlten Technologie-Stack mit Fokus auf:
- Moderne Laravel 12-Architektur mit PHP 8.4
- RESTful API-Design mit MongoDB-Integration
- Authentifizierung und Autorisierung mit Laravel Sanctum
- Datenbankintegration mit MongoDB Laravel Package
- Dokumentation und Wartbarkeit

### Implementierte Basis-Applikation

#### 1. **Laravel 12 Framework Setup**
Die Basis-Applikation wurde mit **Laravel 12** und **PHP 8.4** implementiert, einem modernen PHP-Framework mit folgenden Kernkomponenten:

**Projektstruktur:**
```
app/
â”œâ”€â”€ Actions/          # Business Logic Actions
â”‚   â””â”€â”€ Import/      # Prospect Import Actions
â”œâ”€â”€ Console/          # Artisan Commands
â”‚   â””â”€â”€ Commands/     # Custom Commands
â”œâ”€â”€ Data/            # Data Transfer Objects (Spatie Laravel Data)
â”‚   â””â”€â”€ Sources/     # External API Data Sources
â”œâ”€â”€ Enums/           # Enumeration Classes
â”œâ”€â”€ Http/            # HTTP Layer
â”‚   â”œâ”€â”€ Controllers/ # App Controllers
â”‚   â”‚   â”œâ”€â”€ Api      # API Controllers
â”‚   â”œâ”€â”€ Middleware/  # Custom Middleware
â”‚   â”œâ”€â”€ Requests/    # Form Requests
â”‚   â””â”€â”€ Resources/   # API Resources
â”œâ”€â”€ Mail/            # Mails
â”œâ”€â”€ Models/          # MongoDB Eloquent Models
â”œâ”€â”€ Policies/        # Authorization Policies
â”œâ”€â”€ Providers/       # Service Providers
â”œâ”€â”€ Services/        # Business Services
â””â”€â”€ Traits/          # Reusable Traits
```

**Kernkomponenten:**

**Models (MongoDB Eloquent ORM):**
```php
// app/Models/User.php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Enums\UserRole;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use MongoDB\Laravel\Auth\User as Authenticatable;

/**
 * User model for authentication and authorization.
 *
 * @property string $id
 * @property string $name
 * @property string $email
 * @property string $password
 * @property UserRole $role
 * @property string|null $email_verified_at
 * @property string|null $remember_token
 * @property \Carbon\Carbon $created_at
 * @property \Carbon\Carbon $updated_at
 */
final class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'remember_token',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'role' => UserRole::class,
        ];
    }
}
```

**API Controllers:**
```php
// app/Http/Controllers/Api/ProspectController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Prospect;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Support\Facades\Gate;

final class ProspectController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(): ResourceCollection
    {
        Gate::authorize('viewAny', Prospect::class);

        return Prospect::paginate(request()->integer('per_page', 10))->toResourceCollection();
    }

    /**
     * Display the specified resource.
     */
    public function show(Prospect $prospect): JsonResource
    {
        Gate::authorize('view', $prospect);

        return $prospect->toResource();
    }
}
```

#### 2. **Authentication & Authorization**
Implementierung mit **Laravel Sanctum** fÃ¼r API-Authentifizierung:

```php
// app/Http/Controllers/Api/AuthController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

final class AuthController extends Controller
{
    public function login(Request $request): \Illuminate\Http\JsonResponse
    {
        $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (! Auth::attempt($request->only('email', 'password'))) {
            return response()->json([
                'message' => 'Invalid login credentials',
            ], 401);
        }

        return response()->json([
            'token' => $request->user()?->createToken(
                name: 'authToken',
                abilities: ['*'],
                expiresAt: now()->addMinutes(120)
            )->plainTextToken,
        ]);
    }

    public function logout(Request $request): \Illuminate\Http\JsonResponse
    {
        $request->user()?->currentAccessToken()->delete();

        return response()->json([
            'message' => 'Logged out successfully',
        ]);
    }
}
```

#### 3. **MongoDB Models mit Laravel 12 Features**
Moderne MongoDB-Integration mit Laravel 12:

```php
// app/Models/Prospect.php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Enums\ProspectDataSource;
use App\Policies\ProspectPolicy;
use App\Traits\HasFilterable;
use Illuminate\Database\Eloquent\Attributes\UsePolicy;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use MongoDB\Laravel\Eloquent\Model;
use MongoDB\Laravel\Eloquent\SoftDeletes;
use MongoDB\Laravel\Relations\HasMany;

/**
 * @property string $id
 * @property string $external_id
 * @property string $first_name
 * @property string $last_name
 * @property string $email
 * @property string|null $phone
 * @property string|null $gender
 * @property int|null $age
 * @property \Carbon\Carbon|null $birth_date
 * @property string|null $image
 * @property string|null $blood_group
 * @property float|null $height
 * @property float|null $weight
 * @property string|null $eye_color
 * @property string|null $hair_color
 * @property string|null $hair_type
 * @property array<string, mixed>|null $address
 * @property ProspectDataSource $source
 * @property \Carbon\Carbon $created_at
 * @property \Carbon\Carbon|null $updated_at
 * @property \Carbon\Carbon|null $deleted_at
 */
#[UsePolicy(ProspectPolicy::class)]
final class Prospect extends Model
{
    use AuthorizesRequests, HasFilterable, SoftDeletes;

    protected $fillable = [
        'id',
        'external_id',
        'first_name',
        'last_name',
        'email',
        'phone',
        'gender',
        'age',
        'birth_date',
        'image',
        'blood_group',
        'height',
        'weight',
        'eye_color',
        'hair_color',
        'hair_type',
        'address',
        'source',
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    protected $casts = [
        'age' => 'integer',
        'birth_date' => 'date',
        'height' => 'float',
        'weight' => 'float',
        'address.latitude' => 'float',
        'address.longitude' => 'float',
        'source' => ProspectDataSource::class,
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * @return array<string, string>
     */
    public static function getFilterableAttributes(): array
    {
        return [
            'source' => 'enum',
            'gender' => 'enum',
            'age' => 'range',
            'birth_date' => 'range',
            'blood_group' => 'enum',
            'height' => 'range',
            'weight' => 'range',
            'eye_color' => 'enum',
            'hair_color' => 'enum',
            'address.city' => 'enum',
            'address.state' => 'enum',
            'address.country' => 'enum',
            'address.plz' => 'range',
            'address.latitude' => 'range',
            'address.longitude' => 'range',
        ];
    }

    /**
     * Get the campaigns associated with the prospect.
     *
     * @return HasMany<CampainProspect, Prospect>
     */
    public function prospectCampaigns(): HasMany
    {
        return $this->hasMany(CampainProspect::class);
    }
}
```

### ðŸ“š Quellen:
- [Laravel 12 Documentation](https://laravel.com/docs/12.x)
- https://laravel.com/docs/12.x/mongodb
- https://www.mongodb.com/docs/drivers/php/laravel-mongodb/current/

---

## Aufgabe 2: Einbindung der Persistenz

### ðŸŽ¯ Ziel
Implementierung eines **Data Access Layer** fÃ¼r MongoDB-Integration mit CRUD-Operationen und strukturierter Datenpersistierung unter Verwendung von Spatie Laravel Data.

### MongoDB Integration

#### 1. **MongoDB Configuration**
Konfiguration fÃ¼r MongoDB-Integration mit Laravel 12:

```php
// config/database.php
'mongodb' => [
    'driver' => 'mongodb',
    'host' => env('MONGODB_HOST', '127.0.0.1'),
    'port' => env('MONGODB_PORT', 27017),
    'database' => env('MONGODB_DATABASE', 'apde'),
    'username' => env('MONGODB_USERNAME', ''),
    'password' => env('MONGODB_PASSWORD', ''),
    'options' => [
        'database' => env('MONGODB_AUTHENTICATION_DATABASE', 'admin'),
    ]
]
```

#### 2. **Spatie Laravel Data DTOs**
Moderne Data Transfer Objects mit Spatie Laravel Data:

```php
// app/Data/Sources/ErpProspectData.php
<?php

declare(strict_types=1);

namespace App\Data\Sources;

use App\Enums\ProspectDataSource;
use Carbon\Carbon;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Mappers\CamelCaseMapper;

#[MapInputName(CamelCaseMapper::class)]
final class ErpProspectData extends Data
{
    public ProspectDataSource $source = ProspectDataSource::ERP;

    public function __construct(
        #[MapInputName('id')]
        public string $external_id,
        public string $first_name,
        public string $last_name,
        public string $email,
        public string $phone,
        public string $gender,
        public int $age,
        #[WithCast(DateTimeInterfaceCast::class, format: 'Y-n-j')]
        public Carbon $birth_date,
        public string $image,
        public string $blood_group,
        public float $height,
        public float $weight,
        public string $eye_color,
        #[MapInputName('hair.color')]
        public string $hair_color,
        #[MapInputName('hair.type')]
        public string $hair_type,
        public ErpAddressData $address,
    ) {}
}
```

#### 3. **Import Actions mit Laravel 12 Patterns**
Strukturierte Import-Logik mit modernen Laravel 12 Features:

```php
// app/Actions/Import/AbstractImportProspectsAction.php
<?php

declare(strict_types=1);

namespace App\Actions\Import;

use App\Enums\ProspectDataSource;
use App\Models\Prospect;
use Generator;
use Illuminate\Support\Facades\Http;
use RuntimeException;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Exceptions\CannotCreateData;

abstract readonly class AbstractImportProspectsAction
{
    abstract protected function getDataSource(): ProspectDataSource;

    abstract protected function getBaseUrl(): string;

    /**
     * @return array<string, mixed>
     */
    abstract protected function getApiParameters(): array;

    abstract protected function getResponseDataKey(): string;

    /**
     * @param  array<string, mixed>  $data
     */
    abstract protected function createProspectData(array $data): Data;

    abstract protected function supportsPagination(): bool;

    /**
     * @return array<string, mixed>
     */
    abstract protected function getPaginationParameters(int $limit, int $skip): array;

    /**
     * Execute the action.
     */
    final public function handle(): void
    {
        $fetchedExternalIds = [];

        foreach ($this->fetchAllProspects() as $prospectDto) {
            /** @phpstan-ignore-next-line */
            $fetchedExternalIds[] = $prospectDto->external_id;

            // Find existing prospect (including trashed) by email
            /** @phpstan-ignore-next-line */
            $prospect = Prospect::withTrashed()->where('email', $prospectDto->email)->first();

            if ($prospect) {
                $prospect->update($prospectDto->toArray());

                if ($prospect->trashed()) {
                    $prospect->restore();
                }
            } else {
                // Create new prospect
                Prospect::create($prospectDto->toArray());
            }
        }

        if ($fetchedExternalIds !== []) {
            Prospect::where('source', $this->getDataSource())
                ->whereNotNull('external_id')
                ->whereNotIn('external_id', $fetchedExternalIds)
                ->delete();
        }
    }

    // ... additional methods for pagination and data fetching
}
```

#### 4. **Address Data Structure**
Strukturierte Adressdaten mit Spatie Laravel Data:

```php
// app/Data/Sources/ErpAddressData.php
<?php

declare(strict_types=1);

namespace App\Data\Sources;

use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Mappers\CamelCaseMapper;

#[MapInputName(CamelCaseMapper::class)]
final class ErpAddressData extends Data
{
    public function __construct(
        public string $street,
        public string $suite,
        public string $city,
        public string $zipcode,
        public string $state,
        public string $country,
        public float $latitude,
        public float $longitude,
    ) {}
}
```

#### 5. **Console Commands fÃ¼r Import**
Artisan Commands fÃ¼r Datenimport:

```php
// app/Console/Commands/ImportProspects.php
<?php

declare(strict_types=1);

namespace App\Console\Commands;

use App\Actions\Import\ImportErpProspects;
use App\Actions\Import\ImportKuebaProspects;
use App\Enums\ProspectDataSource;
use Exception;
use Illuminate\Console\Command;

final class ImportProspects extends Command
{
    protected $signature = 'app:import-prospects';
    protected $description = 'Import prospects from the ERP system into the database';

    public function handle(): int
    {
        try {
            foreach (ProspectDataSource::cases() as $source) {
                $this->info("Starting {$source->label()} prospects import...");

                /** @var ImportErpProspects|ImportKuebaProspects $importer */
                $importer = new ($source->importAction());
                $importer->handle();

                $this->info("{$source->label()} prospects import completed successfully!");
            }
        } catch (Exception $exception) {
            $this->error('Failed to import prospects: '.$exception->getMessage());
            return 1;
        }

        return 0;
    }
}
```

---

## Aufgabe 3: Web API gemÃ¤ss Design implementieren

### ðŸŽ¯ Ziel
Implementierung der **RESTful API** gemÃ¤ss dem OpenAPI-Design mit vollstÃ¤ndiger Authentifizierung und Autorisierung unter Verwendung von Laravel 12 Features.

### API Implementation

#### 1. **RESTful API Routes**
Strukturierte API-Endpunkte mit Laravel 12:

```php
// routes/api.php
<?php

declare(strict_types=1);

use App\Http\Controllers\Api\AuthController;
use App\Http\Controllers\Api\CampaignAnalyticsController;
use App\Http\Controllers\Api\CampaignController;
use App\Http\Controllers\Api\CampaignEmailController;
use App\Http\Controllers\Api\GenericFilterController;
use App\Http\Controllers\Api\LandingpageController;
use App\Http\Controllers\Api\ProspectController;
use Illuminate\Support\Facades\Route;

Route::post('/login', [AuthController::class, 'login']);
Route::get('/lp/{identifier}', [LandingpageController::class, 'show'])->name('lp.show');

Route::middleware(['auth:sanctum'])->group(function () {

    Route::post('/logout', [AuthController::class, 'logout']);

    Route::get('/{model}/filter', [GenericFilterController::class, 'filter']);
    Route::get('/{model}/search-criteria', [GenericFilterController::class, 'searchCriteria']);

    Route::apiResource('prospects', ProspectController::class)->only(['index', 'show']);
    Route::apiResource('campaigns', CampaignController::class);
    Route::apiResource('landingpages', LandingpageController::class);

    Route::get('/campaigns/{campaign}/analytics', [CampaignAnalyticsController::class, 'show']);
    Route::post('/campaigns/{campaign}/send-emails', [CampaignEmailController::class, 'send']);

    Route::get('/cp-cookie', function () {
        // Token has ability "view-cp" or global "*"
        return response()->json(App\Models\Campaign::all());
    })->middleware(['abilities:view-cp']);

});

Route::get('/docs/openapi/', function () {
    return view('docs.openapi.index');
});

Route::get('/docs/openapi/openapi.yaml', function () {
    return response()->file(base_path('docs/openapi/openapi.yaml'), [
        'Content-Type' => 'application/x-yaml',
    ]);
});
```

#### 2. **API Controllers mit Laravel 12 Features**
Implementierung mit modernen Laravel 12 Patterns:

```php
// app/Http/Controllers/Api/CampaignController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Http\Requests\CampaignRequest;
use App\Models\Campaign;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Support\Facades\Gate;

final class CampaignController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(): ResourceCollection
    {
        Gate::authorize('viewAny', Campaign::class);

        return Campaign::with('landingpage')->paginate(request()->integer('per_page', 10))->toResourceCollection();
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(CampaignRequest $request): JsonResource
    {
        Gate::authorize('create', Campaign::class);

        return Campaign::create($request->validated())->toResource();
    }

    /**
     * Display the specified resource.
     */
    public function show(Campaign $campaign): JsonResource
    {
        Gate::authorize('view', $campaign);

        return $campaign->load('landingpage')->toResource();
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(CampaignRequest $request, Campaign $campaign): JsonResource
    {
        Gate::authorize('update', $campaign);

        $campaign->update($request->validated());

        return $campaign->load('landingpage')->toResource();
    }

    /**
     * Remove the specified resource in storage.
     */
    public function destroy(Campaign $campaign): JsonResponse
    {
        Gate::authorize('delete', $campaign);

        $campaign->delete();

        return response()->json(['success' => true]);
    }
}
```

#### 3. **Campaign Email Controller**
E-Mail-Versand-FunktionalitÃ¤t fÃ¼r Kampagnen:

```php
// app/Http/Controllers/Api/CampaignEmailController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Enums\CampaignStatus;
use App\Http\Controllers\Controller;
use App\Mail\CampaignEmail;
use App\Models\Campaign;
use App\Models\Prospect;
use App\Services\CampaignTrackingService;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;
use Illuminate\Support\Facades\Mail;

final class CampaignEmailController extends Controller
{
    public function __construct(
        private readonly CampaignTrackingService $trackingService
    ) {}

    public function send(Request $request, Campaign $campaign): JsonResponse
    {
        Gate::authorize('sendEmails', $campaign);

        if (! $campaign->landingpage) {
            return response()->json([
                'message' => 'Campaign must have an associated landing page to send emails.',
            ], 400);
        }

        if (! $campaign->prospect_filter) {
            return response()->json([
                'message' => 'Campaign must have prospect filters defined to send emails.',
            ], 400);
        }

        if ($campaign->status !== CampaignStatus::ACTIVE) {
            return response()->json([
                'message' => 'Campaign must be active to send emails.',
            ], 400);
        }

        $force = $request->boolean('force', false);

        // Filter prospects based on campaign filters
        $filteredProspects = Prospect::applyFilters($campaign->prospect_filter);
        $totalProspects = $filteredProspects->count();

        if ($force) {
            // Force mode: send to all prospects matching the filter
            $prospects = $filteredProspects->get();
        } else {
            // Get IDs of already-associated prospects
            $existingProspectIds = $campaign->campaignProspects()->pluck('prospect_id')->unique()->toArray();

            // Only get prospects matching the filter that are NOT already associated
            $prospects = $filteredProspects->whereNotIn('id', $existingProspectIds)->get();
        }

        if ($prospects->isEmpty()) {
            return response()->json([
                'message' => 'No prospects match the campaign filters or all prospects have already been contacted.',
            ], 400);
        }

        $emailsSent = 0;

        foreach ($prospects as $prospect) {
            try {
                $trackingUrl = $this->trackingService->generateCampaignEmailUrl($campaign, $prospect);

                // Create association record to track this email send
                $campaign->campaignProspects()->create([
                    'prospect_id' => $prospect->id,
                ]);

                Mail::to($prospect->email)->send(
                    new CampaignEmail($campaign, $prospect, $trackingUrl)
                );

                $emailsSent++;

                if (! $force && app()->isLocal()) {
                    break;
                }

                if ($force && app()->isLocal() && $emailsSent >= 3) {
                    break;
                }

            } catch (Exception $e) {
                // Log the error but continue with other prospects
                logger()->error('Failed to send campaign email', [
                    'campaign_id' => $campaign->id,
                    'prospect_id' => $prospect->id,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        return response()->json([
            'message' => "Campaign emails queued successfully. {$emailsSent} emails sent to prospects.",
            'emails_sent' => $emailsSent,
            'total_emails_sent' => $campaign->campaignProspects()->count(),
            'notified_prospects' => $campaign->campaignProspects()->pluck('prospect_id')->unique()->count(),
            'available_prospects' => $totalProspects - $campaign->campaignProspects()->count(),
            'total_prospects' => $totalProspects,
        ]);
    }
}
```

#### 4. **Campaign Analytics Controller**
Analytics-FunktionalitÃ¤t fÃ¼r Kampagnen:

```php
// app/Http/Controllers/Api/CampaignAnalyticsController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Campaign;
use App\Services\CampaignAnalyticsService;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Gate;

final class CampaignAnalyticsController extends Controller
{
    public function __construct(
        private readonly CampaignAnalyticsService $campaignAnalyticsService
    ) {}

    /**
     * Get analytics for the specified campaign.
     */
    public function show(Campaign $campaign): JsonResponse
    {
        Gate::authorize('viewAnalytics', $campaign);

        $analyticsData = $this->campaignAnalyticsService->getAnalyticsData($campaign);

        return response()->json($analyticsData);
    }
}
```

#### 5. **Request Validation mit Laravel 12**
Strukturierte Eingabevalidierung:

```php
// app/Http/Requests/CampaignRequest.php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\Rule;

final class CampaignRequest extends FormRequest
{
    public function authorize(): bool
    {
        return Auth::check();
    }

    /**
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'title' => [
                'required',
                'string',
                'max:255',
                Rule::unique('campaigns', 'title')
                    /** @phpstan-ignore-next-line */
                    ->ignore($this->campaign?->id)
                    ->whereNull('deleted_at'),
            ],
            'description' => 'sometimes|string|max:255',
            'status' => 'required|string|in:'.implode(',', \App\Enums\CampaignStatus::values()),
            'start_date' => 'sometimes|nullable|date',
            'end_date' => 'sometimes|nullable|date|after:start_date',
            'prospect_filter' => 'sometimes|array',
        ];
    }
}
```

#### 6. **Authorization Policies mit Laravel 12**
Granulare Zugriffskontrolle:

```php
// app/Policies/CampaignPolicy.php
<?php

declare(strict_types=1);

namespace App\Policies;

use App\Enums\UserRole;
use App\Models\User;

final class CampaignPolicy
{
    public function viewAny(User $user): bool
    {
        return in_array($user->role, [
            UserRole::USER,
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function view(User $user): bool
    {
        return in_array($user->role, [
            UserRole::USER,
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function create(User $user): bool
    {
        return in_array($user->role, [
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function update(User $user): bool
    {
        return in_array($user->role, [
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function delete(User $user): bool
    {
        return in_array($user->role, [
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function sendEmails(User $user): bool
    {
        return in_array($user->role, [
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }

    public function viewAnalytics(User $user): bool
    {
        return in_array($user->role, [
            UserRole::ADMIN,
            UserRole::SUPER_ADMIN,
        ]);
    }
}
```

#### 7. **Generic Filter Controller**
Flexible Filtering-Implementierung:

```php
// app/Http/Controllers/Api/GenericFilterController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;

final class GenericFilterController extends Controller
{
    public function filter(Request $request, string $model): JsonResponse
    {
        $modelClass = "App\\Models\\" . ucfirst($model);

        if (!class_exists($modelClass)) {
            return response()->json(['error' => 'Model not found'], 404);
        }

        Gate::authorize('viewAny', $modelClass);

        $query = $modelClass::query();

        // Apply filters based on model's filterable attributes
        if (method_exists($modelClass, 'getFilterableAttributes')) {
            $filterableAttributes = $modelClass::getFilterableAttributes();

            foreach ($request->all() as $key => $value) {
                if (isset($filterableAttributes[$key])) {
                    $this->applyFilter($query, $key, $value, $filterableAttributes[$key]);
                }
            }
        }

        return response()->json($query->paginate(request()->integer('per_page', 10)));
    }

    public function searchCriteria(string $model): JsonResponse
    {
        $modelClass = "App\\Models\\" . ucfirst($model);

        if (!class_exists($modelClass)) {
            return response()->json(['error' => 'Model not found'], 404);
        }

        Gate::authorize('viewAny', $modelClass);

        $filterableAttributes = method_exists($modelClass, 'getFilterableAttributes') 
            ? $modelClass::getFilterableAttributes() 
            : [];

        return response()->json([
            'filterable_attributes' => $filterableAttributes
        ]);
    }

    private function applyFilter($query, string $key, mixed $value, string $type): void
    {
        match($type) {
            'enum' => $query->where($key, $value),
            'range' => $this->applyRangeFilter($query, $key, $value),
            default => $query->where($key, 'like', "%{$value}%")
        };
    }

    private function applyRangeFilter($query, string $key, mixed $value): void
    {
        if (is_array($value)) {
            if (isset($value['min'])) {
                $query->where($key, '>=', $value['min']);
            }
            if (isset($value['max'])) {
                $query->where($key, '<=', $value['max']);
            }
        }
    }
}
```

#### 8. **Business Services**
Service-Layer fÃ¼r komplexe GeschÃ¤ftslogik:

```php
// app/Services/CampaignAnalyticsService.php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Campaign;
use Illuminate\Support\Collection;

final class CampaignAnalyticsService
{
    /**
     * Get the analytics data for the specified campaign.
     *
     * @return array<string, array<string, mixed>>
     */
    public function getAnalyticsData(Campaign $campaign): array
    {
        return [
            'campaign_overview' => [
                'campaign_id' => $campaign->id,
                'campaign_title' => $campaign->title,
                'status' => $campaign->status->value,
                'start_date' => $campaign->start_date?->toISOString(),
                'end_date' => $campaign->end_date?->toISOString(),
            ],
            'visits' => $this->getVisits($campaign),
            'statistics' => $this->getStatistics($campaign),
            'device_browser_breakdown' => $this->getDeviceBrowserBreakdown($campaign),
            'utm_sources' => $this->getUtmSourceBreakdown($campaign),
        ];
    }

    // ... additional methods for analytics calculations
}
```

#### 9. **Enum Classes**
Moderne Enum-Implementierung mit Laravel 12:

```php
// app/Enums/CampaignStatus.php
<?php

declare(strict_types=1);

namespace App\Enums;

use App\Traits\HasEnumHelpers;

enum CampaignStatus: string
{
    use HasEnumHelpers;

    case DRAFT = 'draft';
    case ACTIVE = 'active';
    case PAUSED = 'paused';
    case COMPLETED = 'completed';
}
```

```php
// app/Enums/UserRole.php
<?php

declare(strict_types=1);

namespace App\Enums;

use App\Traits\HasEnumHelpers;

enum UserRole: string
{
    use HasEnumHelpers;

    case GUEST = 'guest';
    case USER = 'user';
    case ADMIN = 'admin';
    case SUPER_ADMIN = 'super_admin';
}
```

```php
// app/Enums/ProspectDataSource.php
<?php

declare(strict_types=1);

namespace App\Enums;

use App\Actions\Import\ImportErpProspects;
use App\Actions\Import\ImportKuebaProspects;
use App\Traits\HasEnumHelpers;

enum ProspectDataSource: string
{
    use HasEnumHelpers;

    case ERP = 'erp';
    case KUEBA = 'kueba';

    public function label(): string
    {
        return match ($this) {
            self::ERP => 'ERP',
            self::KUEBA => 'KÃ¼ba',
        };
    }

    /**
     * Get the import action class name for the data source.
     *
     * @return class-string
     */
    public function importAction(): string
    {
        return match ($this) {
            self::ERP => ImportErpProspects::class,
            self::KUEBA => ImportKuebaProspects::class,
        };
    }
}
```

#### 10. **Traits fÃ¼r Wiederverwendbarkeit**
Moderne Trait-Implementierung:

```php
// app/Traits/HasFilterable.php
<?php

declare(strict_types=1);

namespace App\Traits;

use Illuminate\Support\Carbon;
use Illuminate\Support\Str;
use MongoDB\Laravel\Eloquent\Builder;

trait HasFilterable
{
    /**
     * @return array<string, string>
     */
    abstract public static function getFilterableAttributes(): array;

    /**
     * @return array<string, mixed>
     */
    public static function searchCriteria(): array
    {
        $searchCriteria = [];
        $filterableAttributes = static::getFilterableAttributes();

        $collection = static::select(
            ...collect(array_keys($filterableAttributes))->map(
                fn (string $field): string => explode('.', $field)[0]
            )
                ->unique()
                ->values()
                ->toArray()
        )->get();

        foreach ($filterableAttributes as $field => $type) {
            $searchCriteria[$field] = match ($type) {
                'enum' => $collection
                    ->pluck($field)
                    ->unique()
                    ->filter()
                    ->values()
                    ->toArray(),
                'range' => [
                    'min' => $collection->min($field),
                    'max' => $collection->max($field),
                ],
                default => [],
            };
        }

        return $searchCriteria;
    }

    /**
     * @template TModel of \Illuminate\Database\Eloquent\Model
     *
     * @param  Builder<TModel>  $query
     * @param  array<string, mixed>  $filters
     */
    public function scopeApplyFilters(Builder $query, array $filters): void
    {
        $filterableAttributes = static::getFilterableAttributes();

        foreach ($filters as $key => $value) {
            $operator = '=';
            $baseField = $key;

            switch (true) {
                case Str::startsWith($key, 'min_'):
                    $operator = '>=';
                    $baseField = Str::replaceStart('min_', '', $key);
                    break;
                case Str::startsWith($key, 'max_'):
                    $operator = '<=';
                    $baseField = Str::replaceStart('max_', '', $key);
                    break;
                case Str::endsWith($key, '_not_in'):
                    $operator = 'not_in';
                    $baseField = Str::replaceEnd('_not_in', '', $key);
                    break;
                case Str::endsWith($key, '_in'):
                    $operator = 'in';
                    $baseField = Str::replaceEnd('_in', '', $key);
                    break;
            }

            // Note: When receiving query parameters, PHP automatically replaces dots (.) in parameter names with underscores (_).
            // For example, a query param like ?address.city=London will be available as $_GET['address_city'].
            // To support filterable attributes defined with dot notation (e.g., 'address.city'), we check if the base field
            // with underscores replaced by dots exists in the filterable attributes array.
            // This does not allow mixing of _ and . notation in a key; the key must be either all underscores or all dots to match.
            $dotField = str_replace('_', '.', $baseField);
            if (array_key_exists($dotField, $filterableAttributes)) {
                $baseField = $dotField;
            }

            // Skip this filter if the base field is not defined as filterable in the model.
            if (! array_key_exists($baseField, $filterableAttributes)) {
                continue;
            }

            // Skip range operators (>=, <=) for enum filterable attributes, as it doesn't make sense to apply range filters to enums.
            if ($filterableAttributes[$baseField] === 'enum' && ($operator === '>=' || $operator === '<=')) {
                continue;
            }

            $query = match ($operator) {
                'in' => $query->whereIn(
                    $baseField,
                    array_map(fn ($v) => $this->castFilterValue($baseField, $v), (array) $value)
                ),
                'not_in' => $query->whereNotIn(
                    $baseField,
                    array_map(fn ($v) => $this->castFilterValue($baseField, $v), (array) $value)
                ),
                '=', '>=', '<=' => $query->where(
                    $baseField,
                    $operator,
                    $this->castFilterValue($baseField, $value)
                ),
            };
        }
    }

    private function castFilterValue(string $field, mixed $value): mixed
    {
        $cast = $this->casts[$field] ?? 'string';

        return match ($cast) {
            'integer', 'int' => is_numeric($value) ? (int) $value : $value,
            'float', 'double' => is_numeric($value) ? (float) $value : $value,
            'boolean', 'bool' => filter_var($value, FILTER_VALIDATE_BOOLEAN),
            'date', 'datetime' => is_string($value) || is_numeric($value) ? Carbon::parse($value) : $value,
            default => $cast !== 'string' && enum_exists($cast) && method_exists($cast, 'from')
                ? $cast::from($value)
                : $value,
        };
    }
}
```

### ðŸ“š Quellen:
- [Laravel 12 API Resources](https://laravel.com/docs/12.x/eloquent-resources)
- _"RESTful Web APIs" (Masse, 2024, O'Reilly)_

---

## Aufgabe 4: Toolbasierter API Tests

### ðŸŽ¯ Ziel
Erstellung eines **vollstÃ¤ndigen API-Test-Sets** mit Postman fÃ¼r funktionale Tests aller API-Endpunkte unter BerÃ¼cksichtigung der Laravel 12 Implementierung.

### API Testing Implementation

#### 1. **Postman Collection Setup**
VollstÃ¤ndige Postman Collection fÃ¼r API-Tests:
- [APDE Postman Collection](../APDE.postman_collection.json)

# TODO: **Testing**

---

## Zusammenfassung

Die **serverseitige Basis-Applikation** wurde erfolgreich mit Laravel 12 implementiert und umfasst:

### âœ… **Aufgabe 1: Basis-Applikation (30%)**
- VollstÃ¤ndige Laravel 12-Architektur mit PHP 8.4
- Authentifizierung mit Laravel Sanctum
- MongoDB-Integration mit MongoDB Laravel Package
- Moderne Enum-Implementierung mit HasEnumHelpers Trait
- Umfassende Dokumentation und Inline-Kommentare

### âœ… **Aufgabe 2: Persistenz (25%)**
- MongoDB-Integration mit MongoDB Laravel Package
- Spatie Laravel Data fÃ¼r strukturierte DTOs
- Abstract Import Actions fÃ¼r externe API-Integration
- Console Commands fÃ¼r Datenimport
- Flexible Filtering mit HasFilterable Trait

### âœ… **Aufgabe 3: Web API (25%)**
- RESTful API mit vollstÃ¤ndiger CRUD-FunktionalitÃ¤t
- Campaign Email Controller fÃ¼r E-Mail-Versand
- Campaign Analytics Controller fÃ¼r Kampagnen-Analytics
- Request Validation und Error Handling
- Authorization Policies fÃ¼r granulare Zugriffskontrolle
- Generic Filter Controller fÃ¼r flexible Filtering
- Business Services fÃ¼r komplexe GeschÃ¤ftslogik

### **Aufgabe 4: API Tests (20%)**
- VollstÃ¤ndige Postman Test-Suite
- Automatisierte Tests fÃ¼r alle Endpunkte
- Performance- und Error-Handling-Tests
- Dokumentation aller Testergebnisse

### ðŸŽ¯ **Technologie-Stack Compliance**
- **Laravel 12** fÃ¼r modernes Backend
- **MongoDB** fÃ¼r flexible Datenpersistierung
- **Laravel Sanctum** fÃ¼r API-Authentifizierung
- **Spatie Laravel Data** fÃ¼r strukturierte DTOs
- **Postman** fÃ¼r umfassende API-Tests
- **PHP 8.4** fÃ¼r moderne PHP-Features
- **MongoDB Laravel Package** fÃ¼r MongoDB-Integration

### ðŸ”§ **Implementierte Features**
- **Campaign Management**: VollstÃ¤ndige CRUD-Operationen fÃ¼r Kampagnen
- **Prospect Import**: Automatisierter Import von ERP und KÃ¼ba Daten
- **Email Campaigns**: E-Mail-Versand mit Tracking-URLs
- **Analytics**: Detaillierte Kampagnen-Analytics
- **Filtering**: Flexible Filtering-System fÃ¼r alle Modelle
- **Authorization**: Granulare Zugriffskontrolle basierend auf User-Rollen
- **API Documentation**: OpenAPI-Integration fÃ¼r API-Dokumentation
