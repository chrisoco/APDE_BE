# 4.2 Server App

## Aufgabe 1: Serverseitige Basis Applikation

### ðŸŽ¯ Ziel
Implementierung einer **Laravel 12-basierten Server-Applikation** gemÃ¤ss dem gewÃ¤hlten Technologie-Stack mit Fokus auf:
- Moderne Laravel 12-Architektur mit PHP 8.4
- RESTful API-Design mit MongoDB-Integration
- Authentifizierung und Autorisierung mit Laravel Sanctum
- Datenbankintegration mit MongoDB Laravel Package
- Dokumentation und Wartbarkeit

### Implementierte Basis-Applikation

#### 1. **Laravel 12 Framework Setup**
Die Basis-Applikation wurde mit **Laravel 12** und **PHP 8.4** implementiert, einem modernen PHP-Framework mit folgenden Kernkomponenten:

**Projektstruktur:**
```
app/
â”œâ”€â”€ Actions/          # Business Logic Actions
â”œâ”€â”€ Console/          # Artisan Commands
â”œâ”€â”€ Data/            # Data Transfer Objects (Spatie Laravel Data)
â”œâ”€â”€ Enums/           # Enumeration Classes
â”œâ”€â”€ Http/            # HTTP Layer
â”‚   â”œâ”€â”€ Controllers/ # App Controllers
â”‚   â”‚   â”œâ”€â”€ Api      # API Controllers
â”‚   â”œâ”€â”€ Middleware/  # Custom Middleware
â”‚   â”œâ”€â”€ Requests/    # Form Requests
â”‚   â””â”€â”€ Resources/   # API Resources
â”œâ”€â”€ Mail/            # Mails
â”œâ”€â”€ Models/          # MongoDB Eloquent Models
â”œâ”€â”€ Policies/        # Authorization Policies
â”œâ”€â”€ Providers/       # Service Providers
â”œâ”€â”€ Services/        # Business Services
â”œâ”€â”€ Services/        # Business Services
â””â”€â”€ Traits/          # Reusable Traits
```

**Kernkomponenten:**

**Models (MongoDB Eloquent ORM):**
```php
// app/Models/User.php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Enums\UserRole;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use MongoDB\Laravel\Auth\User as Authenticatable;

/**
 * User model for authentication and authorization.
 *
 * @property string $id
 * @property string $name
 * @property string $email
 * @property string $password
 * @property UserRole $role
 * @property string|null $email_verified_at
 * @property string|null $remember_token
 * @property \Carbon\Carbon $created_at
 * @property \Carbon\Carbon $updated_at
 */
final class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'remember_token',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'role' => UserRole::class,
        ];
    }
}
```

**API Controllers:**
```php
// app/Http/Controllers/Api/ProspectController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Prospect;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Support\Facades\Gate;

final class ProspectController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(): ResourceCollection
    {
        Gate::authorize('viewAny', Prospect::class);

        return Prospect::paginate(request()->integer('per_page', 10))->toResourceCollection();
    }

    /**
     * Display the specified resource.
     */
    public function show(Prospect $prospect): JsonResource
    {
        Gate::authorize('view', $prospect);

        return $prospect->toResource();
    }
}
```

#### 2. **Authentication & Authorization**
Implementierung mit **Laravel Sanctum** fÃ¼r API-Authentifizierung:

```php
// app/Http/Controllers/Api/AuthController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

final class AuthController extends Controller
{
    public function login(Request $request): \Illuminate\Http\JsonResponse
    {
        $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (! Auth::attempt($request->only('email', 'password'))) {
            return response()->json([
                'message' => 'Invalid login credentials',
            ], 401);
        }

        return response()->json([
            'token' => $request->user()?->createToken(
                name: 'authToken',
                abilities: ['*'],
                expiresAt: now()->addMinutes(120)
            )->plainTextToken,
        ]);
    }

    public function logout(Request $request): \Illuminate\Http\JsonResponse
    {
        $request->user()?->currentAccessToken()->delete();

        return response()->json([
            'message' => 'Logged out successfully',
        ]);
    }
}
```

#### 3. **MongoDB Models mit Laravel 12 Features**
Moderne MongoDB-Integration mit Laravel 12:

```php
// app/Models/Prospect.php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Enums\ProspectDataSource;
use App\Policies\ProspectPolicy;
use App\Traits\HasFilterable;
use Illuminate\Database\Eloquent\Attributes\UsePolicy;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use MongoDB\Laravel\Eloquent\Model;
use MongoDB\Laravel\Eloquent\SoftDeletes;

/**
 * @property string $id
 * @property string $external_id
 * @property string $first_name
 * @property string $last_name
 * @property string $email
 * @property string|null $phone
 * @property string|null $gender
 * @property int|null $age
 * @property \Carbon\Carbon|null $birth_date
 * @property string|null $image
 * @property string|null $blood_group
 * @property float|null $height
 * @property float|null $weight
 * @property string|null $eye_color
 * @property string|null $hair_color
 * @property string|null $hair_type
 * @property array<string, mixed>|null $address
 * @property ProspectDataSource $source
 * @property \Carbon\Carbon $created_at
 * @property \Carbon\Carbon|null $updated_at
 * @property \Carbon\Carbon|null $deleted_at
 */
#[UsePolicy(ProspectPolicy::class)]
final class Prospect extends Model
{
    use AuthorizesRequests, HasFilterable, SoftDeletes;

    protected $fillable = [
        'id',
        'external_id',
        'first_name',
        'last_name',
        'email',
        'phone',
        'gender',
        'age',
        'birth_date',
        'image',
        'blood_group',
        'height',
        'weight',
        'eye_color',
        'hair_color',
        'hair_type',
        'address',
        'source',
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    protected $casts = [
        'age' => 'integer',
        'birth_date' => 'date',
        'height' => 'float',
        'weight' => 'float',
        'address.latitude' => 'float',
        'address.longitude' => 'float',
        'source' => ProspectDataSource::class,
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * @return array<string, string>
     */
    public static function getFilterableAttributes(): array
    {
        return [
            'source' => 'enum',
            'gender' => 'enum',
            'age' => 'range',
            'birth_date' => 'range',
            'blood_group' => 'enum',
            'height' => 'range',
            'weight' => 'range',
            'eye_color' => 'enum',
            'hair_color' => 'enum',
            'address.city' => 'enum',
            'address.state' => 'enum',
            'address.country' => 'enum',
            'address.plz' => 'range',
            'address.latitude' => 'range',
            'address.longitude' => 'range',
        ];
    }
}
```

### ðŸ“š Quellen:
- [Laravel 12 Documentation](https://laravel.com/docs/12.x)
- https://laravel.com/docs/12.x/mongodb
- https://www.mongodb.com/docs/drivers/php/laravel-mongodb/current/

---

## Aufgabe 2: Einbindung der Persistenz

### ðŸŽ¯ Ziel
Implementierung eines **Data Access Layer** fÃ¼r MongoDB-Integration mit CRUD-Operationen und strukturierter Datenpersistierung unter Verwendung von Spatie Laravel Data.

### MongoDB Integration

#### 1. **MongoDB Configuration**
Konfiguration fÃ¼r MongoDB-Integration mit Laravel 12:

```php
// config/database.php
'mongodb' => [
    'driver' => 'mongodb',
    'host' => env('MONGODB_HOST', '127.0.0.1'),
    'port' => env('MONGODB_PORT', 27017),
    'database' => env('MONGODB_DATABASE', 'apde'),
    'username' => env('MONGODB_USERNAME', ''),
    'password' => env('MONGODB_PASSWORD', ''),
    'options' => [
        'database' => env('MONGODB_AUTHENTICATION_DATABASE', 'admin'),
    ]
]
```

#### 2. **Spatie Laravel Data DTOs**
Moderne Data Transfer Objects mit Spatie Laravel Data:

```php
// app/Data/Sources/ErpProspectData.php
<?php

declare(strict_types=1);

namespace App\Data\Sources;

use App\Enums\ProspectDataSource;
use Carbon\Carbon;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Mappers\CamelCaseMapper;

#[MapInputName(CamelCaseMapper::class)]
final class ErpProspectData extends Data
{
    public ProspectDataSource $source = ProspectDataSource::ERP;

    public function __construct(
        #[MapInputName('id')]
        public string $external_id,
        public string $first_name,
        public string $last_name,
        public string $email,
        public string $phone,
        public string $gender,
        public int $age,
        #[WithCast(DateTimeInterfaceCast::class, format: 'Y-n-j')]
        public Carbon $birth_date,
        public string $image,
        public string $blood_group,
        public float $height,
        public float $weight,
        public string $eye_color,
        #[MapInputName('hair.color')]
        public string $hair_color,
        #[MapInputName('hair.type')]
        public string $hair_type,
        public ErpAddressData $address,
    ) {}
}
```

#### 3. **Import Actions mit Laravel 12 Patterns**
Strukturierte Import-Logik mit modernen Laravel 12 Features:

```php
// app/Actions/Import/ImportErpProspects.php
<?php

declare(strict_types=1);

namespace App\Actions\Import;

use App\Data\Sources\ErpProspectData;
use App\Enums\ProspectDataSource;
use Illuminate\Support\Facades\Config;

final readonly class ImportErpProspects extends AbstractImportProspectsAction
{
    protected function getDataSource(): ProspectDataSource
    {
        return ProspectDataSource::ERP;
    }

    protected function getBaseUrl(): string
    {
        return Config::string('services.erp.prospects.url');
    }

    /**
     * @return array<string, mixed>
     */
    protected function getApiParameters(): array
    {
        return [];
    }

    protected function getResponseDataKey(): string
    {
        return 'users';
    }

    /**
     * @param  array<string, mixed>  $data
     */
    protected function createProspectData(array $data): ErpProspectData
    {
        return ErpProspectData::from($data);
    }

    protected function supportsPagination(): bool
    {
        return true;
    }

    /**
     * @return array<string, mixed>
     */
    protected function getPaginationParameters(int $limit, int $skip): array
    {
        return [
            'limit' => $limit,
            'skip' => $skip,
        ];
    }
}
```

#### 4. **Address Data Structure**
Strukturierte Adressdaten mit Spatie Laravel Data:

```php
// app/Data/Sources/ErpAddressData.php
<?php

declare(strict_types=1);

namespace App\Data\Sources;

use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Mappers\CamelCaseMapper;

#[MapInputName(CamelCaseMapper::class)]
final class ErpAddressData extends Data
{
    public function __construct(
        public string $street,
        public string $suite,
        public string $city,
        public string $zipcode,
        public string $state,
        public string $country,
        public float $latitude,
        public float $longitude,
    ) {}
}
```
---

## Aufgabe 3: Web API gemÃ¤ss Design implementieren

### ðŸŽ¯ Ziel
Implementierung der **RESTful API** gemÃ¤ss dem OpenAPI-Design mit vollstÃ¤ndiger Authentifizierung und Autorisierung unter Verwendung von Laravel 12 Features.

### API Implementation

#### 1. **RESTful API Routes**
Strukturierte API-Endpunkte mit Laravel 12:

```php
// routes/api.php
<?php

declare(strict_types=1);

use App\Http\Controllers\Api\AuthController;
use App\Http\Controllers\Api\CampaignController;
use App\Http\Controllers\Api\GenericFilterController;
use App\Http\Controllers\Api\LandingpageController;
use App\Http\Controllers\Api\ProspectController;
use Illuminate\Support\Facades\Route;

Route::post('/login', [AuthController::class, 'login']);
Route::get('/lp/{identifier}', [LandingpageController::class, 'show'])->name('lp.show');

Route::middleware(['auth:sanctum'])->group(function () {

    Route::post('/logout', [AuthController::class, 'logout']);

    Route::get('/{model}/filter', [GenericFilterController::class, 'filter']);
    Route::get('/{model}/search-criteria', [GenericFilterController::class, 'searchCriteria']);

    Route::apiResource('prospects', ProspectController::class)->only(['index', 'show']);
    Route::apiResource('campaigns', CampaignController::class);
    Route::apiResource('landingpages', LandingpageController::class);

    Route::get('/cp-cookie', function () {
        // Token has ability "view-cp" or global "*"
        return response()->json(App\Models\Campaign::all());
    })->middleware(['abilities:view-cp']);

});
```

#### 2. **API Controllers mit Laravel 12 Features**
Implementierung mit modernen Laravel 12 Patterns:

```php
// app/Http/Controllers/Api/CampaignController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Campaign;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Support\Facades\Gate;

final class CampaignController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(): ResourceCollection
    {
        Gate::authorize('viewAny', Campaign::class);

        return Campaign::with(['prospects', 'landingpage'])
            ->when(request('status'), function ($query, $status) {
                return $query->where('status', $status);
            })
            ->when(request('search'), function ($query, $search) {
                return $query->where('name', 'like', "%{$search}%");
            })
            ->paginate(request()->integer('per_page', 15))
            ->toResourceCollection();
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(CampaignRequest $request): JsonResource
    {
        Gate::authorize('create', Campaign::class);

        $campaign = Campaign::create($request->validated());

        return $campaign->toResource();
    }

    /**
     * Display the specified resource.
     */
    public function show(Campaign $campaign): JsonResource
    {
        Gate::authorize('view', $campaign);

        return $campaign->load(['prospects', 'landingpage'])->toResource();
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(CampaignRequest $request, Campaign $campaign): JsonResource
    {
        Gate::authorize('update', $campaign);

        $campaign->update($request->validated());

        return $campaign->toResource();
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Campaign $campaign): \Illuminate\Http\JsonResponse
    {
        Gate::authorize('delete', $campaign);

        $campaign->delete();

        return response()->json(['message' => 'Campaign deleted successfully']);
    }
}
```

#### 3. **Request Validation mit Laravel 12**
Strukturierte Eingabevalidierung:

```php
// app/Http/Requests/CampaignRequest.php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Enums\CampaignStatus;
use Illuminate\Foundation\Http\FormRequest;

final class CampaignRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user()->can('create', Campaign::class);
    }

    /**
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'status' => 'required|in:' . implode(',', CampaignStatus::values()),
            'landingpage_id' => 'nullable|exists:landingpages,id',
            'email_template' => 'nullable|string',
            'subject_line' => 'nullable|string|max:255',
            'scheduled_at' => 'nullable|date|after:now',
            'metadata' => 'nullable|array'
        ];
    }

    /**
     * @return array<string, string>
     */
    public function messages(): array
    {
        return [
            'name.required' => 'Campaign name is required',
            'status.in' => 'Invalid campaign status',
            'scheduled_at.after' => 'Campaign must be scheduled for future date'
        ];
    }
}
```

#### 4. **Authorization Policies mit Laravel 12**
Granulare Zugriffskontrolle:

```php
// app/Policies/CampaignPolicy.php
<?php

declare(strict_types=1);

namespace App\Policies;

use App\Enums\UserRole;
use App\Models\Campaign;
use App\Models\User;

final class CampaignPolicy
{
    public function viewAny(User $user): bool
    {
        return in_array($user->role, [UserRole::ADMIN, UserRole::MANAGER, UserRole::USER]);
    }

    public function view(User $user, Campaign $campaign): bool
    {
        return $user->role === UserRole::ADMIN || $campaign->user_id === $user->id;
    }

    public function create(User $user): bool
    {
        return in_array($user->role, [UserRole::ADMIN, UserRole::MANAGER]);
    }

    public function update(User $user, Campaign $campaign): bool
    {
        return $user->role === UserRole::ADMIN || $campaign->user_id === $user->id;
    }

    public function delete(User $user, Campaign $campaign): bool
    {
        return $user->role === UserRole::ADMIN;
    }
}
```

#### 5. **Generic Filter Controller**
Flexible Filtering-Implementierung:

```php
// app/Http/Controllers/Api/GenericFilterController.php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;

final class GenericFilterController extends Controller
{
    public function filter(Request $request, string $model): JsonResponse
    {
        $modelClass = "App\\Models\\" . ucfirst($model);

        if (!class_exists($modelClass)) {
            return response()->json(['error' => 'Model not found'], 404);
        }

        Gate::authorize('viewAny', $modelClass);

        $query = $modelClass::query();

        // Apply filters based on model's filterable attributes
        if (method_exists($modelClass, 'getFilterableAttributes')) {
            $filterableAttributes = $modelClass::getFilterableAttributes();

            foreach ($request->all() as $key => $value) {
                if (isset($filterableAttributes[$key])) {
                    $this->applyFilter($query, $key, $value, $filterableAttributes[$key]);
                }
            }
        }

        return response()->json($query->paginate(request()->integer('per_page', 10)));
    }

    public function searchCriteria(string $model): JsonResponse
    {
        $modelClass = "App\\Models\\" . ucfirst($model);

        if (!class_exists($modelClass)) {
            return response()->json(['error' => 'Model not found'], 404);
        }

        Gate::authorize('viewAny', $modelClass);

        $filterableAttributes = method_exists($modelClass, 'getFilterableAttributes') 
            ? $modelClass::getFilterableAttributes() 
            : [];

        return response()->json([
            'filterable_attributes' => $filterableAttributes
        ]);
    }

    private function applyFilter($query, string $key, mixed $value, string $type): void
    {
        match($type) {
            'enum' => $query->where($key, $value),
            'range' => $this->applyRangeFilter($query, $key, $value),
            default => $query->where($key, 'like', "%{$value}%")
        };
    }

    private function applyRangeFilter($query, string $key, mixed $value): void
    {
        if (is_array($value)) {
            if (isset($value['min'])) {
                $query->where($key, '>=', $value['min']);
            }
            if (isset($value['max'])) {
                $query->where($key, '<=', $value['max']);
            }
        }
    }
}
```

#### 6. **Error Handling mit Laravel 12**
Strukturierte Fehlerbehandlung:

```php
// app/Exceptions/Handler.php
<?php

declare(strict_types=1);

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Throwable;

final class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void
    {
        $this->renderable(function (Throwable $e, Request $request) {
            if ($request->expectsJson()) {
                return response()->json([
                    'error' => $e->getMessage(),
                    'code' => $e->getCode() ?: 500
                ], $e->getCode() ?: 500);
            }
        });
    }
}
```

### ðŸ“š Quellen:
- [Laravel 12 API Resources](https://laravel.com/docs/12.x/eloquent-resources)
- _"RESTful Web APIs" (Masse, 2024, O'Reilly)_

---

## Aufgabe 4: Toolbasierter API Tests

### ðŸŽ¯ Ziel
Erstellung eines **vollstÃ¤ndigen API-Test-Sets** mit Postman fÃ¼r funktionale Tests aller API-Endpunkte unter BerÃ¼cksichtigung der Laravel 12 Implementierung.

### API Testing Implementation

#### 1. **Postman Collection Setup**
VollstÃ¤ndige Postman Collection fÃ¼r API-Tests:
- [APDE Postman Collection](../APDE.postman_collection.json)

# TODO: **Testing**

---

## Zusammenfassung

Die **serverseitige Basis-Applikation** wurde erfolgreich mit Laravel 12 implementiert und umfasst:

### âœ… **Aufgabe 1: Basis-Applikation (30%)**
- VollstÃ¤ndige Laravel 12-Architektur mit PHP 8.4
- Authentifizierung mit Laravel Sanctum
- MongoDB-Integration mit MongoDB Laravel Package
- (Umfassende Dokumentation und Inline-Kommentare)

### âœ… **Aufgabe 2: Persistenz (25%)**
- MongoDB-Integration mit Jenssegers Package
- Spatie Laravel Data fÃ¼r strukturierte DTOs
- Data Access Layer mit (Repository Pattern) Controllers?

### âœ… **Aufgabe 3: Web API (25%)**
- RESTful API mit vollstÃ¤ndiger CRUD-FunktionalitÃ¤t
- Request Validation und Error Handling
- Authorization Policies fÃ¼r Zugriffskontrolle
- Generic Filter Controller fÃ¼r flexible Filtering

### **Aufgabe 4: API Tests (20%)**
- VollstÃ¤ndige Postman Test-Suite
- Automatisierte Tests fÃ¼r alle Endpunkte
- Performance- und Error-Handling-Tests
- Dokumentation aller Testergebnisse

### ðŸŽ¯ **Technologie-Stack Compliance**
- **Laravel 12** fÃ¼r modernes Backend
- **MongoDB** fÃ¼r flexible Datenpersistierung
- **Laravel Sanctum** fÃ¼r API-Authentifizierung
- **Spatie Laravel Data** fÃ¼r strukturierte DTOs
- **Postman** fÃ¼r umfassende API-Tests
