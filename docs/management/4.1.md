# 4.1 Softwarearchitektur , technologisches Design und Entwicklungsumgebung
## Aufgabe 1
BegruÌˆndete Wahl des Technologie Stacks: BegruÌˆnde deine Auswahl der Technologie-Stack-Elemente unter BeruÌˆcksichtigung von Skalierbarkeit, Performance, Kosten und Wartbarkeit. Zudem sollte auf die spezifischen Anforderungen der Applikation (verteilte Architektur, Client und Server Kommunikation) eingegangen werden.
### ğŸ¯ Ziel
Ein **fundierter Technologie-Stack** fÃ¼r eine verteilte Webanwendung zur Verwaltung von E-Mail-Kampagnen mit Fokus auf:
- Skalierbarkeit
- Performance
- Kosten
- Wartbarkeit
- Verteilte Architektur
- API-Integration
### GewÃ¤hlter Technologie-Stack

| Bereich               | Technologie / Tool |
| --------------------- | ------------------ |
| **Frontend (SPA)**    | React.js + TypeScript + Tailwind CSS |
| **Mobile-App**        | React Native |
| **Backend**           | Laravel (PHP Framework) |
| **Datenbank**         | MongoDB |
| **API-Dokumentation** | OpenAPI (YAML) mit SwaggerUI / Postman |
| **Authentication**    | Laravel Sanctum |
| **Dev-Tools**         | VSCode oder Cursor.ai, Git, Figma?, Postman, GitHub Actions?, Mermaid.js, Drawsql, draw.io, PlantUml? |
| **KI-UnterstÃ¼tzung**  | Cursor.ai, Lovable.dev, ChatGPT, GitHub Copilot |
### ğŸ“˜ BegrÃ¼ndung nach Bereichen (Ausformuliert)
#### 1. **Frontend: React.js + TypeScript + Tailwind CSS**
React ermÃ¶glicht als modernes JavaScript-Framework die Entwicklung einer performanten SPA mit Wiederverwendbarkeit von Komponenten und gutem Ecosystem. TypeScript bringt zusÃ¤tzlich statische Typisierung und reduziert damit Fehlerquellen im UI-Code.  
Tailwind CSS erlaubt durch Utility-First-Ansatz ein schnelles und konsistentes UI-Design â€“ ideal fÃ¼r responsive Anwendungen.

ğŸ“š **Quellen**:
- _"Learning React" (Banks & Porcello, 2023, Oâ€™Reilly)_
- [React Official Docs](https://react.dev)
- [Tailwind CSS Docs](https://tailwindcss.com)
#### 2. **Backend: Laravel (PHP)**
Laravel ist ein leistungsfÃ¤higes, robustes MVC-Framework mit elegantem Syntax und breiter Community. Die Entscheidung fÃ¼r Laravel basiert auf der bestehenden langjÃ¤hrigen Erfahrung im Entwicklerteam, wodurch **Kosten und Einarbeitungszeit reduziert** werden.  
Laravel bietet integrierte LÃ¶sungen fÃ¼r Authentifizierung, API-Erstellung (mit Laravel Sanctum oder Passport), E-Mail-Versand und Datenvalidierung. Die Wartbarkeit und Erweiterbarkeit sind durch klare Trennung von Logik und PrÃ¤sentation gewÃ¤hrleistet.

ğŸ“š **Quellen**:
- [Laravel.com Documentation](https://laravel.com/docs)
#### 3. **Datenbank: MongoDB**
Als NoSQL-Datenbank ist MongoDB optimal geeignet fÃ¼r flexible Datenstrukturen, z.â€¯B. dynamische Kampagneninhalte oder Kundeninteraktionen.  
Sie ist skalierbar, schemalos und integriert sich gut mit Laravel via Bibliotheken wie Laravel MongoDB (Jenssegers). Das Format (JSON) passt gut zu REST-APIs.

ğŸ“š **Quellen**:
- [MongoDB Documentation](https://www.mongodb.com)
#### 4. **API-Dokumentation: Swagger/OpenAPI (YAML)**
FÃ¼r die maschinenlesbare Beschreibung der REST-Schnittstellen wird OpenAPI in YAML eingesetzt. Das erlaubt z.â€¯B. automatische Mock-Server, Generierung von API-Clients oder TestfÃ¤llen.  
Swagger UI bietet eine intuitive OberflÃ¤che zur interaktiven Nutzung und PrÃ¼fung der Schnittstellen durch Entwickler und Stakeholder.

ğŸ“š **Quellen**:
- [Swagger.io](https://swagger.io)
#### 5. **Dev-Tools & KI-UnterstÃ¼tzung**
- **VS Code oder Cursor.ai** als leistungsfÃ¤hige, erweiterbare IDEs mit UnterstÃ¼tzung fÃ¼r PHP, JavaScript und TypeScript.
- **?Figma** fÃ¼r UI-/UX-Wireframes.
- **Postman** zur API-Entwicklung und Testautomatisierung.
- **GitHub Actions** fÃ¼r automatisiertes CI/CD.
- **Cloudflare** Ã¼bernimmt DNS, Web Application Firewall (WAF), Caching und DDoS-Schutz.
- **[Cursor.ai](https://www.cursor.com/)** & **[Lovable.dev](https://lovable.dev/)** bieten KI-unterstÃ¼tzte CodevorschlÃ¤ge und Refactoring.
- **Mailtrap:** eine Sandbox-Umgebung fÃ¼r den sicheren Versand und die Analyse von E-Mails. Sie verhindert den unbeabsichtigten Versand an reale Benutzer und erlaubt gleichzeitig die PrÃ¼fung von Layouts und Header-Daten.

ğŸ“š **Quellen**:
- [Mailtrap.io Documentation](https://mailtrap.io/docs/)
- [GitHub Actions Docs](https://docs.github.com/en/actions)
- [Cloudflare Developer Docs](https://developers.cloudflare.com/)

---
## Aufgabe 2
Design der Softwarearchitektur fuÌˆr die verteilte Applikation : Entwurf einer Architektur, die die Trennung von Client und Server klar definiert. Es muss ein adÃ¤quates Diagramm ausgewÃ¤hlt und angewendet werden, um die Beziehungen zwischen den Komponenten und ihren Verantwortlichkeiten darzustellen.

### ğŸ¯ Ziel
Entwurf einer **verteilten Softwarearchitektur**, die die Trennung zwischen Client und Server klar darstellt, und die Integration von Umsystemen berÃ¼cksichtigt.

### GewÃ¤hlte Architektur: Three-Tier Architecture mit REST API

Die Anwendung folgt einer **dreistufigen Architektur** (Three-Tier Architecture) mit klarer Trennung von PrÃ¤sentations-, GeschÃ¤fts- und Datenschicht:

#### Architekturdiagramm: Komponentendiagramm (UML)

```mermaid
%%{init: {'theme': 'default'}}%%
graph TB
    subgraph "Presentation Tier (Client)"
        subgraph "React SPA"
            UI[React Components]
            STATE[State Management]
            AUTH[Authentication Module]
            API_CLIENT[API Client Layer]
        end
        
        subgraph "Mobile App"
            MOBILE_UI[React Native Components]
            MOBILE_STATE[Mobile State Management]
            MOBILE_API[Mobile API Client]
        end
    end
    subgraph "Application Tier (Server)"
        subgraph "Laravel Backend"
            ROUTES[API Routes]
            MIDDLEWARE[Authentication Middleware]
            CONTROLLERS[Controllers]
            SERVICES[Business Logic Services]
            POLICIES[Authorization Policies]
            RESOURCES[API Resources]
        end
        
        subgraph "External Services"
            MAILTRAP[Mailtrap Email Service]
            QUEUE[Queue System]
        end
    end
    subgraph "Data Tier"
        MONGODB[(MongoDB Database)]
        
        subgraph "External APIs"
            ERP[ERP System API]
            KUEBA[KÃ¼ba AG API]
        end
    end
    %% Client to Server Communication
    UI --> API_CLIENT
    STATE --> API_CLIENT
    AUTH --> API_CLIENT
    API_CLIENT --> ROUTES
    
    MOBILE_UI --> MOBILE_API
    MOBILE_STATE --> MOBILE_API
    MOBILE_API --> ROUTES
    %% Server Internal Flow
    ROUTES --> MIDDLEWARE
    MIDDLEWARE --> CONTROLLERS
    CONTROLLERS --> SERVICES
    CONTROLLERS --> POLICIES
    CONTROLLERS --> RESOURCES
    SERVICES --> MONGODB
    SERVICES --> ERP
    SERVICES --> KUEBA
    SERVICES --> MAILTRAP
    CONTROLLERS --> QUEUE
    %% Data Flow
    MONGODB -.-> SERVICES
    ERP -.-> SERVICES
    KUEBA -.-> SERVICES
```

#### Komponentenbeschreibung

**Presentation Tier (Client-Seite):**
- **React Components**: Modulare UI-Komponenten fÃ¼r Kampagnenerstellung, Analytics und Landing Pages. Verantwortlich fÃ¼r die Darstellung und Benutzerinteraktion.
- **State Management**: Zentrale Zustandsverwaltung fÃ¼r Anwendungsdaten, implementiert mit React Context oder Redux. Koordiniert Datenfluss zwischen Komponenten.
- **API Client Layer**: Abstraktionsschicht fÃ¼r HTTP-Kommunikation mit dem Backend. Behandelt Authentication, Error Handling und Request/Response-Transformation.

**Application Tier (Server-Seite):**
- **API Routes**: REST-Endpunkte definiert in Laravel, die HTTP-Requests entgegennehmen und an entsprechende Controller weiterleiten.
- **Controllers**: Koordinieren den Datenfluss zwischen Client-Requests und Business Logic Services. Implementieren Input-Validierung und Response-Formatting.
- **Business Logic Services**: KerngeschÃ¤ftslogik fÃ¼r Kampagnenmanagement, Prospect-Import und Analytics. Kapseln komplexe Operationen und External API-Calls.

**Data Tier:**
- **MongoDB Database**: NoSQL-Datenbank fÃ¼r flexible Speicherung von Kampagnen, Prospects und Tracking-Daten. UnterstÃ¼tzt Schema-Evolution und horizontale Skalierung.
- **External APIs**: ERP-System fÃ¼r Kundendaten und KÃ¼ba AG fÃ¼r Lead-Generierung. Bieten strukturierte Datenquellen fÃ¼r Prospect-Segmentierung.

### Integration mit Umsystemen

Die Architektur integriert folgende externe Systeme Ã¼ber REST-APIs:

1. **ERP-System Integration**: Ãœber `ImportErpProspects` Action mit standardisiertem `ErpProspectData` DTO
2. **KÃ¼ba AG API**: Ãœber `ImportKuebaProspects` Action mit `KuebaProspectData` DTO  
3. **Mailtrap Email Service**: FÃ¼r sicheren E-Mail-Versand und Testing Ã¼ber SMTP/REST API
4. **Queue System**: FÃ¼r asynchrone Verarbeitung von E-Mail-Kampagnen und Datenimporten

### BegrÃ¼ndung der Architekturwahl

**Skalierbarkeit**: Die drei-Tier Architektur ermÃ¶glicht unabhÃ¤ngige Skalierung von Frontend, Backend und Datenbank je nach Lastanforderungen.

**Wartbarkeit**: Klare Trennung der Verantwortlichkeiten durch Schichten-Prinzip. Services kapseln Business Logic, Controllers handhaben HTTP-Kommunikation.

**Performance**: Stateless REST API ermÃ¶glicht horizontale Skalierung. MongoDB bietet optimierte Abfragen fÃ¼r Campaign Analytics.

ğŸ“š **Quellen**:
- _"Software Architecture Patterns" (Richards, 2015, O'Reilly)_
- [Laravel Architecture Concepts](https://laravel.com/docs/architecture)

---

## Aufgabe 3
Toolbasiertes Design und Dokumentation der APIs : BegruÌˆndete Wahl der API Technologie sowie deren Dokumentations Tools. VollstÃ¤ndige Erstellung des API Designs fuÌˆr die gemÃ¤ss der Ausgangslage angebotene Web API. Dabei ist aber nur ein Datenobjekt vorzusehen.

### ğŸ¯ Ziel
BegrÃ¼ndete Wahl der API-Technologie und Dokumentationstools sowie vollstÃ¤ndige Erstellung des API-Designs fÃ¼r die Web API mit einem Datenobjekt.

### GewÃ¤hlte API-Technologie: REST mit OpenAPI 3.0

#### BegrÃ¼ndung der API-Technologiewahl

**REST (Representational State Transfer)** wurde als API-Architektur gewÃ¤hlt aufgrund folgender Vorteile:

- **Standardisierung**: HTTP-basiert mit etablierten Verben (GET, POST, PUT, DELETE)
- **Stateless**: Jeder Request ist unabhÃ¤ngig, was horizontale Skalierung ermÃ¶glicht
- **Caching**: UnterstÃ¼tzt HTTP-Caching-Mechanismen fÃ¼r bessere Performance
- **Tooling**: Breite UnterstÃ¼tzung durch Entwicklungstools und Frameworks

#### Dokumentationstools

**OpenAPI 3.0 (YAML)** fÃ¼r API-Spezifikation:
- Maschinenlesbare Dokumentation ermÃ¶glicht automatische Code-Generierung
- Swagger UI fÃ¼r interaktive API-Dokumentation
- UnterstÃ¼tzung fÃ¼r Request/Response-Validierung

**Implementierte Tools**:
- **Swagger UI**: FÃ¼r interaktive API-Exploration und Testing
- **Postman Collection**: FÃ¼r automatisierte API-Tests
- **Laravel API Resources**: FÃ¼r konsistente JSON-Response-Struktur

### API-Design: Campaign Management API

Das API-Design fokussiert auf das **Campaign** Datenobjekt als zentrales Element:

#### OpenAPI 3.0 Spezifikation (YAML)
- [http://apde_be.test/api/docs/openapi/](http://apde_be.test/api/docs/openapi/)
- [http://localhost:8000/api/docs/openapi/](http://localhost:8000/api/docs/openapi/)

### Implementierungsdetails
**Laravel API Resources** sorgen fÃ¼r konsistente JSON-Responses:
```php
class CampaignResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'id' => $this->id,
            'title' => $this->title,
            'description' => $this->description,
            'status' => $this->status->value,
            'start_date' => $this->start_date?->toISOString(),
            'end_date' => $this->end_date?->toISOString(),
            'prospect_filter' => $this->prospect_filter,
            'created_at' => $this->created_at->toISOString(),
            'updated_at' => $this->updated_at->toISOString(),
            'landingpage' => new LandingpageResource($this->whenLoaded('landingpage')),
        ];
    }
}
```

### BegrÃ¼ndung der Toolwahl

**OpenAPI 3.0**: Industriestandard fÃ¼r REST API-Dokumentation, ermÃ¶glicht automatische Validierung und Code-Generierung.

**Swagger UI**: Bietet interaktive Dokumentation, die von Entwicklern und Stakeholdern gleichermaÃŸen genutzt werden kann.

**Laravel Sanctum**: Leichtgewichtige Token-basierte Authentifizierung, optimal fÃ¼r SPA-Anwendungen.

ğŸ“š **Quellen**:
- _"REST API Design Rulebook" (Masse, 2011, O'Reilly)_
- [OpenAPI Specification 3.0](https://spec.openapis.org/oas/v3.0.3)

---

## Aufgabe 4
Auswahl einer geeigneten Entwicklungsumgebung unter begruÌˆndeter BeruÌˆcksichtigung der KI UnterstuÌˆtzung.

## Form der Antwort
Die Struktur der Antwort muss sich an die Aufgabenstruktur halten und eine ent-sprechende Titelstruktur aufweisen.
Die geforderten Auswahlen sind jeweils mit einer fundierten Herleitung und mit mindestens je 2 Quellen (mind. je 1 aktuelles Fachbuch sowie je 1 Internetquelle) gut begruÌˆndet darzulegen.
Jedes Element des geforderten Diagramms muss kurz (in 2-3 SÃ¤tzen) beschrie-ben sein.
Das API-Design sollte in einem maschinenlesbaren Format (z.B. YAML) doku-mentiert werden, um eine einfache Integration und spÃ¤tere Erweiterungen zu ermÃ¶glichen.

## Hinweise
BeruÌˆcksichtige fuÌˆr den Technologie-Stack folgende Aspekte:
- Serverseitig: Middleware, Frameworks, Programmiersprache, Datenbank
- Clientseitig: Frameworks, Programmiersprache, Runtime U mgebungen

Die Softwarearchitektur muss folgende Aspekte abdecken:
- Server und Clientseitige Architektur mit deren Pakete und Komponenten
- Integration mit den Umsystemen uÌˆber adÃ¤quate Schnittstellen

BeruÌˆcksichtige fuÌˆr die Entwicklungsumgebung Tools fuÌˆr folgende Aspekte:
- UI Wireframing
- IDE
- Unit Testing
- API Testing
- KI UnterstuÌˆtzung
- Versions kontrolle