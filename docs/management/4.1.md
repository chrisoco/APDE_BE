# 4.1 Softwarearchitektur , technologisches Design und Entwicklungsumgebung
## Aufgabe 1
Begr√ºndete Wahl des Technologie Stacks: Begr√ºnde deine Auswahl der Technologie-Stack-Elemente unter Ber√ºcksichtigung von Skalierbarkeit, Performance, Kosten und Wartbarkeit. Zudem sollte auf die spezifischen Anforderungen der Applikation (verteilte Architektur, Client und Server Kommunikation) eingegangen werden.
### üéØ Ziel
Ein **fundierter Technologie-Stack** f√ºr eine verteilte Webanwendung zur Verwaltung von E-Mail-Kampagnen mit Fokus auf:
- Skalierbarkeit
- Performance
- Kosten
- Wartbarkeit
- Verteilte Architektur
- API-Integration
### Gew√§hlter Technologie-Stack

| Bereich               | Technologie / Tool |
| --------------------- | ------------------ |
| **Frontend (SPA)**    | React.js + TypeScript + Tailwind CSS |
| **Mobile-App**        | React Native |
| **Backend**           | Laravel (PHP Framework) |
| **Datenbank**         | MongoDB |
| **API-Dokumentation** | OpenAPI (YAML) mit SwaggerUI / Postman |
| **Authentication**    | Laravel Sanctum |
| **API-Dokumentation** | OpenAPI 3.1.1 (YAML) mit SwaggerUI |
| **Data Transfer Objects** | Spatie Laravel Data |
| **Code Quality**      | PHPStan (Level 10), Laravel Pint, Rector |
| **Testing**           | Pest PHP |
| **Frontend Assets**   | Vite + Tailwind CSS 4.0 |
| **Dev-Tools**         | Cursor.ai, Git, Postman |
| **KI-Unterst√ºtzung**  | Cursor.ai, GitHub Copilot, Claude |

### üìò Begr√ºndung nach Bereichen (Ausformuliert)
#### 1. **Frontend: React.js + TypeScript + Tailwind CSS**
React erm√∂glicht als modernes JavaScript-Framework die Entwicklung einer performanten SPA mit Wiederverwendbarkeit von Komponenten und gutem Ecosystem. TypeScript bringt zus√§tzlich statische Typisierung und reduziert damit Fehlerquellen im UI-Code.  
Tailwind CSS erlaubt durch Utility-First-Ansatz ein schnelles und konsistentes UI-Design ‚Äì ideal f√ºr responsive Anwendungen.

üìö **Quellen**:
- _"Learning React" (Banks & Porcello, 2023, O‚ÄôReilly)_
- [React Official Docs](https://react.dev)
- [Tailwind CSS Docs](https://tailwindcss.com)
#### 2. **Backend: Laravel (PHP)**
Laravel ist ein leistungsf√§higes, robustes MVC-Framework mit elegantem Syntax und breiter Community. Die Entscheidung f√ºr Laravel basiert auf der bestehenden langj√§hrigen Erfahrung im Entwicklerteam, wodurch **Kosten und Einarbeitungszeit reduziert** werden.  
Laravel bietet integrierte L√∂sungen f√ºr Authentifizierung, API-Erstellung (mit Laravel Sanctum oder Passport), E-Mail-Versand und Datenvalidierung. Die Wartbarkeit und Erweiterbarkeit sind durch klare Trennung von Logik und Pr√§sentation gew√§hrleistet.

üìö **Quellen**:
- [Laravel.com Documentation](https://laravel.com/docs)
#### 3. **Datenbank: MongoDB**
Als NoSQL-Datenbank ist MongoDB optimal geeignet f√ºr flexible Datenstrukturen, z.‚ÄØB. dynamische Kampagneninhalte oder Kundeninteraktionen.  
Sie ist skalierbar, schemalos und integriert sich gut mit Laravel via Bibliotheken wie Laravel MongoDB (Jenssegers). Das Format (JSON) passt gut zu REST-APIs.

üìö **Quellen**:
- [MongoDB Documentation](https://www.mongodb.com)
- [Laravel MongoDB Package](https://github.com/jenssegers/laravel-mongodb)

#### 4. **Authentication: Laravel Sanctum**
Laravel Sanctum bietet leichte Token-basierte Authentifizierung, optimal f√ºr API-Anwendungen. Es unterst√ºtzt sowohl Token-basierte als auch Session-basierte Authentifizierung und ist bereits in Laravel integriert.

üìö **Quellen**:
- [Laravel Sanctum Documentation](https://laravel.com/docs/sanctum)

#### 5. **API-Dokumentation: OpenAPI 3.1.1 (YAML)**
F√ºr die maschinenlesbare Beschreibung der REST-Schnittstellen wird OpenAPI 3.1.1 in YAML eingesetzt. Das erlaubt z. B. automatische Mock-Server, Generierung von API-Clients oder Testf√§llen. Swagger UI bietet eine intuitive Oberfl√§che zur interaktiven Nutzung und Pr√ºfung der Schnittstellen durch Entwickler und Stakeholder.

üìö **Quellen**:
- [Swagger.io](https://swagger.io)
- [OpenAPI Specification 3.1.1](https://spec.openapis.org/oas/v3.1.1)

#### 6. **Data Transfer Objects: Spatie Laravel Data**
Spatie Laravel Data bietet typsichere DTOs f√ºr API-Requests und Responses. Es unterst√ºtzt automatische Validierung, Transformation und Serialisierung von Daten zwischen API-Layer und Business Logic.

üìö **Quellen**:
- [Spatie Laravel Data Documentation](https://spatie.be/docs/laravel-data)

#### 7. **Code Quality Tools**
- **PHPStan (Level 10)**: Statische Code-Analyse f√ºr h√∂chste Code-Qualit√§t
- **Laravel Pint**: Automatische Code-Formatierung nach PSR-12 Standards
- **Rector**: Automatische Code-Modernisierung und Refactoring
- **Pest PHP**: Modernes Testing-Framework mit expressiver Syntax

üìö **Quellen**:
- [PHPStan Documentation](https://phpstan.org)
- [Laravel Pint Documentation](https://laravel.com/docs/pint)
- [Pest PHP Documentation](https://pestphp.com)

#### 8. **Frontend Assets: Vite + Tailwind CSS 4.0**
Vite bietet schnelle Build-Tools f√ºr moderne Frontend-Entwicklung. Tailwind CSS 4.0 mit Utility-First-Ansatz erm√∂glicht schnelles und konsistentes UI-Design f√ºr responsive Anwendungen.

üìö **Quellen**:
- [Vite Documentation](https://vitejs.dev)
- [Tailwind CSS Documentation](https://tailwindcss.com)

---
## Aufgabe 2
Design der Softwarearchitektur fuÃàr die verteilte Applikation : Entwurf einer Architektur, die die Trennung von Client und Server klar definiert. Es muss ein ad√§quates Diagramm ausgew√§hlt und angewendet werden, um die Beziehungen zwischen den Komponenten und ihren Verantwortlichkeiten darzustellen.

### üéØ Ziel
Entwurf einer **verteilten Softwarearchitektur**, die die Trennung zwischen Client und Server klar darstellt, und die Integration von Umsystemen ber√ºcksichtigt.

### Gew√§hlte Architektur: Three-Tier Architecture mit REST API

Die Anwendung folgt einer **dreistufigen Architektur** (Three-Tier Architecture) mit klarer Trennung von Pr√§sentations-, Gesch√§fts- und Datenschicht:

#### Architekturdiagramm: Komponentendiagramm (UML)

```mermaid
%%{init: {'theme': 'default'}}%%
graph TB
    subgraph "Presentation Tier (Client)"
        subgraph "React SPA"
            UI[React Components]
            STATE[State Management]
            AUTH[Authentication Module]
            API_CLIENT[API Client Layer]
        end
        
        subgraph "Mobile App"
            MOBILE_UI[React Native Components]
            MOBILE_STATE[Mobile State Management]
            MOBILE_API[Mobile API Client]
        end
    end
    subgraph "Application Tier (Server)"
        subgraph "Laravel Backend"
            ROUTES[API Routes]
            MIDDLEWARE[Sanctum Authentication]
            CONTROLLERS[Controllers]
            SERVICES[Business Logic Services]
            POLICIES[Authorization Policies]
            RESOURCES[API Resources]
            DTOs[Data Transfer Objects]
        end
        
        subgraph "External Services"
            MAILTRAP[Mailtrap Email Service]
            QUEUE[Queue System]
        end
    end
    subgraph "Data Tier"
        MONGODB[(MongoDB Database)]
        
        subgraph "External APIs"
            ERP[ERP System API]
            KUEBA[K√ºba AG API]
        end
    end
    %% Client to Server Communication
    UI --> API_CLIENT
    STATE --> API_CLIENT
    AUTH --> API_CLIENT
    API_CLIENT --> ROUTES
    
    MOBILE_UI --> MOBILE_API
    MOBILE_STATE --> MOBILE_API
    MOBILE_API --> ROUTES
    %% Server Internal Flow
    ROUTES --> MIDDLEWARE
    MIDDLEWARE --> CONTROLLERS
    CONTROLLERS --> SERVICES
    CONTROLLERS --> POLICIES
    CONTROLLERS --> RESOURCES
    CONTROLLERS --> DTOs
    SERVICES --> MONGODB
    SERVICES --> ERP
    SERVICES --> KUEBA
    SERVICES --> MAILTRAP
    CONTROLLERS --> QUEUE
    %% Data Flow
    MONGODB -.-> SERVICES
    ERP -.-> SERVICES
    KUEBA -.-> SERVICES
```

#### Komponentenbeschreibung

**Presentation Tier (Client-Seite):**
- **React Components**: Modulare UI-Komponenten f√ºr Kampagnenerstellung, Analytics und Landing Pages. Verantwortlich f√ºr die Darstellung und Benutzerinteraktion.
- **State Management**: Zentrale Zustandsverwaltung f√ºr Anwendungsdaten, implementiert mit React Context oder Redux. Koordiniert Datenfluss zwischen Komponenten.
- **API Client Layer**: Abstraktionsschicht f√ºr HTTP-Kommunikation mit dem Backend. Behandelt Authentication, Error Handling und Request/Response-Transformation.

**Application Tier (Server-Seite):**
- **API Routes**: REST-Endpunkte definiert in Laravel, die HTTP-Requests entgegennehmen und an entsprechende Controller weiterleiten.
- **Controllers**: Koordinieren den Datenfluss zwischen Client-Requests und Business Logic Services. Implementieren Input-Validierung und Response-Formatting.
- **Business Logic Services**: Kerngesch√§ftslogik f√ºr Kampagnenmanagement, Prospect-Import und Analytics. Kapseln komplexe Operationen und External API-Calls.
- **Data Transfer Objects**: Typsichere DTOs f√ºr API-Requests und Responses mit automatischer Validierung und Transformation.

**Data Tier:**
- **MongoDB Database**: NoSQL-Datenbank f√ºr flexible Speicherung von Kampagnen, Prospects und Tracking-Daten. Unterst√ºtzt Schema-Evolution und horizontale Skalierung.
- **External APIs**: ERP-System f√ºr Kundendaten und K√ºba AG f√ºr Lead-Generierung. Bieten strukturierte Datenquellen f√ºr Prospect-Segmentierung.

### Integration mit Umsystemen

Die Architektur integriert folgende externe Systeme √ºber REST-APIs:

1. **ERP-System Integration**: √úber `ImportErpProspects` Action mit standardisiertem `ErpProspectData` DTO
2. **K√ºba AG API**: √úber `ImportKuebaProspects` Action mit `KuebaProspectData` DTO  
3. **Mailtrap Email Service**: F√ºr sicheren E-Mail-Versand und Testing √ºber SMTP/REST API
4. **Queue System**: F√ºr asynchrone Verarbeitung von E-Mail-Kampagnen und Datenimporten

### Begr√ºndung der Architekturwahl

**Skalierbarkeit**: Die drei-Tier Architektur erm√∂glicht unabh√§ngige Skalierung von Frontend, Backend und Datenbank je nach Lastanforderungen.

**Wartbarkeit**: Klare Trennung der Verantwortlichkeiten durch Schichten-Prinzip. Services kapseln Business Logic, Controllers handhaben HTTP-Kommunikation.

**Performance**: Stateless REST API erm√∂glicht horizontale Skalierung. MongoDB bietet optimierte Abfragen f√ºr Campaign Analytics.

üìö **Quellen**:
- _"Software Architecture Patterns" (Richards, 2015, O'Reilly)_
- [Laravel Architecture Concepts](https://laravel.com/docs/architecture)

---

## Aufgabe 3
Toolbasiertes Design und Dokumentation der APIs : BegruÃàndete Wahl der API Technologie sowie deren Dokumentations Tools. Vollst√§ndige Erstellung des API Designs fuÃàr die gem√§ss der Ausgangslage angebotene Web API. Dabei ist aber nur ein Datenobjekt vorzusehen.

### üéØ Ziel
Begr√ºndete Wahl der API-Technologie und Dokumentationstools sowie vollst√§ndige Erstellung des API-Designs f√ºr die Web API mit einem Datenobjekt.

### Gew√§hlte API-Technologie: REST mit OpenAPI 3.1.1

#### Begr√ºndung der API-Technologiewahl

**REST (Representational State Transfer)** wurde als API-Architektur gew√§hlt aufgrund folgender Vorteile:

- **Standardisierung**: HTTP-basiert mit etablierten Verben (GET, POST, PUT, DELETE)
- **Stateless**: Jeder Request ist unabh√§ngig, was horizontale Skalierung erm√∂glicht
- **Caching**: Unterst√ºtzt HTTP-Caching-Mechanismen f√ºr bessere Performance
- **Tooling**: Breite Unterst√ºtzung durch Entwicklungstools und Frameworks

#### Dokumentationstools

**OpenAPI 3.1.1 (YAML)** f√ºr API-Spezifikation:
- Maschinenlesbare Dokumentation erm√∂glicht automatische Code-Generierung
- Swagger UI f√ºr interaktive API-Dokumentation
- Unterst√ºtzung f√ºr Request/Response-Validierung

**Implementierte Tools**:
- **Swagger UI**: F√ºr interaktive API-Exploration und Testing
- **Postman Collection**: F√ºr automatisierte API-Tests
- **Laravel API Resources**: F√ºr konsistente JSON-Response-Struktur

### API-Design: Campaign Management API

Das API-Design fokussiert auf das **Campaign** Datenobjekt als zentrales Element:

#### OpenAPI 3.1.1 Spezifikation (YAML)
- [http://apde_be.test/api/docs/openapi/](http://apde_be.test/api/docs/openapi/)
- [http://localhost:8000/api/docs/openapi/](http://localhost:8000/api/docs/openapi/)

### Implementierungsdetails
**Laravel API Resources** sorgen f√ºr konsistente JSON-Responses:
```php
class CampaignResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'id' => $this->id,
            'title' => $this->title,
            'description' => $this->description,
            'status' => $this->status->label(),
            'start_date' => $this->start_date?->toISOString(),
            'end_date' => $this->end_date?->toISOString(),
            'prospect_filter' => $this->prospect_filter ?? [],
            'landingpage' => new LandingpageResource($this->whenLoaded('landingpage')),
        ];
    }
}
```

### Begr√ºndung der Toolwahl

**OpenAPI 3.1.1**: Industriestandard f√ºr REST API-Dokumentation, erm√∂glicht automatische Validierung und Code-Generierung.

**Swagger UI**: Bietet interaktive Dokumentation, die von Entwicklern und Stakeholdern gleichermassen genutzt werden kann.

**Laravel Sanctum**: Leichtgewichtige Token-basierte Authentifizierung, optimal f√ºr API-Anwendungen.

üìö **Quellen**:
- _"REST API Design Rulebook" (Masse, 2011, O'Reilly)_
- [OpenAPI Specification 3.1.1](https://spec.openapis.org/oas/v3.1.1)

---

## Aufgabe 4
Auswahl einer geeigneten Entwicklungsumgebung unter begr√ºndeter Ber√ºcksichtigung der KI Unterst√ºtzung.

### üéØ Ziel
Begr√ºndete Auswahl einer Entwicklungsumgebung mit KI-Unterst√ºtzung f√ºr optimale Produktivit√§t und Code-Qualit√§t.

### Gew√§hlte Entwicklungsumgebung

#### IDE: Cursor.ai
**Cursor.ai** wurde als prim√§re IDE gew√§hlt aufgrund folgender Vorteile:

- **KI-Integration**: Native Integration von GPT-4 f√ºr Code-Generierung und Refactoring
- **Laravel Support**: Optimierte Unterst√ºtzung f√ºr Laravel-Frameworks
- **PHP 8.4 Support**: Vollst√§ndige Unterst√ºtzung f√ºr moderne PHP-Features
- **Git Integration**: Nahtlose Git-Integration mit intelligenten Commit-Messages
- **Debugging**: Erweiterte Debugging-Funktionen f√ºr PHP-Anwendungen

#### Code Quality Tools
- **PHPStan (Level 10)**: H√∂chste Stufe der statischen Code-Analyse f√ºr maximale Code-Qualit√§t
- **Laravel Pint**: Automatische Code-Formatierung nach PSR-12 Standards
- **Rector**: Automatische Code-Modernisierung und Refactoring
- **Pest PHP**: Modernes Testing-Framework mit expressiver Syntax

#### API Testing
- **Postman**: Umfassende API-Testumgebung mit Collection-Management
- **Swagger UI**: Interaktive API-Dokumentation und Testing
- **Laravel Sanctum**: Token-basierte Authentifizierung f√ºr API-Tests

#### Version Control
- **Git**: Distributed Version Control System
- **GitHub**: Remote Repository mit CI/CD Integration
- **GitHub Actions**: Automatisierte Tests und Deployment

#### KI-Unterst√ºtzung
- **Cursor.ai**: Native KI-Integration f√ºr Code-Generierung
- **GitHub Copilot**: KI-gest√ºtzte Code-Vervollst√§ndigung
- **ChatGPT**: Erg√§nzende KI-Unterst√ºtzung f√ºr komplexe Probleml√∂sungen

### Begr√ºndung der Toolwahl

**Cursor.ai**: Bietet die beste Integration von KI-Funktionen mit moderner IDE-Funktionalit√§t f√ºr Laravel-Entwicklung.

**PHPStan Level 10**: Garantiert h√∂chste Code-Qualit√§t durch umfassende statische Analyse.

**Pest PHP**: Modernes Testing-Framework mit expressiver Syntax und besserer Lesbarkeit als PHPUnit.

üìö **Quellen**:
- [Cursor.ai Documentation](https://cursor.sh/docs)
- [PHPStan Documentation](https://phpstan.org)
- [Pest PHP Documentation](https://pestphp.com)

---

## Form der Antwort
Die Struktur der Antwort muss sich an die Aufgabenstruktur halten und eine ent-sprechende Titelstruktur aufweisen.
Die geforderten Auswahlen sind jeweils mit einer fundierten Herleitung und mit mindestens je 2 Quellen (mind. je 1 aktuelles Fachbuch sowie je 1 Internetquelle) gut begruÃàndet darzulegen.
Jedes Element des geforderten Diagramms muss kurz (in 2-3 S√§tzen) beschrie-ben sein.
Das API-Design sollte in einem maschinenlesbaren Format (z.B. YAML) doku-mentiert werden, um eine einfache Integration und sp√§tere Erweiterungen zu erm√∂glichen.

## Hinweise
Ber√ºcksichtige f√ºr den Technologie-Stack folgende Aspekte:
- Serverseitig: Middleware, Frameworks, Programmiersprache, Datenbank
- Clientseitig: Frameworks, Programmiersprache, Runtime Umgebungen

Die Softwarearchitektur muss folgende Aspekte abdecken:
- Server und Clientseitige Architektur mit deren Pakete und Komponenten
- Integration mit den Umsystemen √ºber ad√§quate Schnittstellen

Ber√ºcksichtige f√ºr die Entwicklungsumgebung Tools f√ºr folgende Aspekte:
- IDE
- Unit Testing
- API Testing
- KI Unterst√ºtzung
- Versionskontrolle