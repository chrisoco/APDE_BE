# 4.1 Softwarearchitektur , technologisches Design und Entwicklungsumgebung
## Aufgabe 1
BegruÃàndete Wahl des Technologie Stacks: BegruÃànde deine Auswahl der Technologie-Stack-Elemente unter BeruÃàcksichtigung von Skalierbarkeit, Performance, Kosten und Wartbarkeit. Zudem sollte auf die spezifischen Anforderungen der Applikation (verteilte Architektur, Client und Server Kommunikation) eingegangen werden.
### üéØ Ziel
Ein **fundierter Technologie-Stack** f√ºr eine verteilte Webanwendung zur Verwaltung von E-Mail-Kampagnen mit Fokus auf:
- Skalierbarkeit
- Performance
- Kosten
- Wartbarkeit
- Verteilte Architektur
- API-Integration
### Gew√§hlter Technologie-Stack

| Bereich               | Technologie / Tool |
| --------------------- | ------------------ |
| **Frontend (SPA)**    | React.js + TypeScript + Tailwind CSS |
| **Mobile-App**        | React Native |
| **Backend**           | Laravel (PHP Framework) |
| **Datenbank**         | MongoDB |
| **API-Dokumentation** | OpenAPI (YAML) mit SwaggerUI / Postman |
| **Authentication**    | Laravel Sanctum |
| **Dev-Tools**         | VSCode oder Cursor.ai, Git, Figma?, Postman, GitHub Actions?, Mermaid.js, Drawsql, draw.io, PlantUml? |
| **KI-Unterst√ºtzung**  | Cursor.ai, Lovable.dev, ChatGPT, GitHub Copilot |
### üìò Begr√ºndung nach Bereichen (Ausformuliert)
#### 1. **Frontend: React.js + TypeScript + Tailwind CSS**
React erm√∂glicht als modernes JavaScript-Framework die Entwicklung einer performanten SPA mit Wiederverwendbarkeit von Komponenten und gutem Ecosystem. TypeScript bringt zus√§tzlich statische Typisierung und reduziert damit Fehlerquellen im UI-Code.  
Tailwind CSS erlaubt durch Utility-First-Ansatz ein schnelles und konsistentes UI-Design ‚Äì ideal f√ºr responsive Anwendungen.

üìö **Quellen**:
- _"Learning React" (Banks & Porcello, 2023, O‚ÄôReilly)_
- [React Official Docs](https://react.dev)
- [Tailwind CSS Docs](https://tailwindcss.com)
#### 2. **Backend: Laravel (PHP)**
Laravel ist ein leistungsf√§higes, robustes MVC-Framework mit elegantem Syntax und breiter Community. Die Entscheidung f√ºr Laravel basiert auf der bestehenden langj√§hrigen Erfahrung im Entwicklerteam, wodurch **Kosten und Einarbeitungszeit reduziert** werden.  
Laravel bietet integrierte L√∂sungen f√ºr Authentifizierung, API-Erstellung (mit Laravel Sanctum oder Passport), E-Mail-Versand und Datenvalidierung. Die Wartbarkeit und Erweiterbarkeit sind durch klare Trennung von Logik und Pr√§sentation gew√§hrleistet.

üìö **Quellen**:
- [Laravel.com Documentation](https://laravel.com/docs)
#### 3. **Datenbank: MongoDB**
Als NoSQL-Datenbank ist MongoDB optimal geeignet f√ºr flexible Datenstrukturen, z.‚ÄØB. dynamische Kampagneninhalte oder Kundeninteraktionen.  
Sie ist skalierbar, schemalos und integriert sich gut mit Laravel via Bibliotheken wie Laravel MongoDB (Jenssegers). Das Format (JSON) passt gut zu REST-APIs.

üìö **Quellen**:
- [MongoDB Documentation](https://www.mongodb.com)
#### 4. **API-Dokumentation: Swagger/OpenAPI (YAML)**
F√ºr die maschinenlesbare Beschreibung der REST-Schnittstellen wird OpenAPI in YAML eingesetzt. Das erlaubt z.‚ÄØB. automatische Mock-Server, Generierung von API-Clients oder Testf√§llen.  
Swagger UI bietet eine intuitive Oberfl√§che zur interaktiven Nutzung und Pr√ºfung der Schnittstellen durch Entwickler und Stakeholder.

üìö **Quellen**:
- [Swagger.io](https://swagger.io)
#### 5. **Dev-Tools & KI-Unterst√ºtzung**
- **VS Code oder Cursor.ai** als leistungsf√§hige, erweiterbare IDEs mit Unterst√ºtzung f√ºr PHP, JavaScript und TypeScript.
- **?Figma** f√ºr UI-/UX-Wireframes.
- **Postman** zur API-Entwicklung und Testautomatisierung.
- **GitHub Actions** f√ºr automatisiertes CI/CD.
- **Cloudflare** √ºbernimmt DNS, Web Application Firewall (WAF), Caching und DDoS-Schutz.
- **[Cursor.ai](https://www.cursor.com/)** & **[Lovable.dev](https://lovable.dev/)** bieten KI-unterst√ºtzte Codevorschl√§ge und Refactoring.
- **Mailtrap:** eine Sandbox-Umgebung f√ºr den sicheren Versand und die Analyse von E-Mails. Sie verhindert den unbeabsichtigten Versand an reale Benutzer und erlaubt gleichzeitig die Pr√ºfung von Layouts und Header-Daten.

üìö **Quellen**:
- [Mailtrap.io Documentation](https://mailtrap.io/docs/)
- [GitHub Actions Docs](https://docs.github.com/en/actions)
- [Cloudflare Developer Docs](https://developers.cloudflare.com/)

---
## Aufgabe 2
Design der Softwarearchitektur fuÃàr die verteilte Applikation : Entwurf einer Architektur, die die Trennung von Client und Server klar definiert. Es muss ein ad√§quates Diagramm ausgew√§hlt und angewendet werden, um die Beziehungen zwischen den Komponenten und ihren Verantwortlichkeiten darzustellen.

### üéØ Ziel
Entwurf einer **verteilten Softwarearchitektur**, die die Trennung zwischen Client und Server klar darstellt, und die Integration von Umsystemen ber√ºcksichtigt.

### Gew√§hlte Architektur: Three-Tier Architecture mit REST API

Die Anwendung folgt einer **dreistufigen Architektur** (Three-Tier Architecture) mit klarer Trennung von Pr√§sentations-, Gesch√§fts- und Datenschicht:

#### Architekturdiagramm: Komponentendiagramm (UML)

```mermaid
%%{init: {'theme': 'default'}}%%
graph TB
    subgraph "Presentation Tier (Client)"
        subgraph "React SPA"
            UI[React Components]
            STATE[State Management]
            AUTH[Authentication Module]
            API_CLIENT[API Client Layer]
        end
        
        subgraph "Mobile App"
            MOBILE_UI[React Native Components]
            MOBILE_STATE[Mobile State Management]
            MOBILE_API[Mobile API Client]
        end
    end
    subgraph "Application Tier (Server)"
        subgraph "Laravel Backend"
            ROUTES[API Routes]
            MIDDLEWARE[Authentication Middleware]
            CONTROLLERS[Controllers]
            SERVICES[Business Logic Services]
            POLICIES[Authorization Policies]
            RESOURCES[API Resources]
        end
        
        subgraph "External Services"
            MAILTRAP[Mailtrap Email Service]
            QUEUE[Queue System]
        end
    end
    subgraph "Data Tier"
        MONGODB[(MongoDB Database)]
        
        subgraph "External APIs"
            ERP[ERP System API]
            KUEBA[K√ºba AG API]
        end
    end
    %% Client to Server Communication
    UI --> API_CLIENT
    STATE --> API_CLIENT
    AUTH --> API_CLIENT
    API_CLIENT --> ROUTES
    
    MOBILE_UI --> MOBILE_API
    MOBILE_STATE --> MOBILE_API
    MOBILE_API --> ROUTES
    %% Server Internal Flow
    ROUTES --> MIDDLEWARE
    MIDDLEWARE --> CONTROLLERS
    CONTROLLERS --> SERVICES
    CONTROLLERS --> POLICIES
    CONTROLLERS --> RESOURCES
    SERVICES --> MONGODB
    SERVICES --> ERP
    SERVICES --> KUEBA
    SERVICES --> MAILTRAP
    CONTROLLERS --> QUEUE
    %% Data Flow
    MONGODB -.-> SERVICES
    ERP -.-> SERVICES
    KUEBA -.-> SERVICES
```

#### Komponentenbeschreibung

**Presentation Tier (Client-Seite):**
- **React Components**: Modulare UI-Komponenten f√ºr Kampagnenerstellung, Analytics und Landing Pages. Verantwortlich f√ºr die Darstellung und Benutzerinteraktion.
- **State Management**: Zentrale Zustandsverwaltung f√ºr Anwendungsdaten, implementiert mit React Context oder Redux. Koordiniert Datenfluss zwischen Komponenten.
- **API Client Layer**: Abstraktionsschicht f√ºr HTTP-Kommunikation mit dem Backend. Behandelt Authentication, Error Handling und Request/Response-Transformation.

**Application Tier (Server-Seite):**
- **API Routes**: REST-Endpunkte definiert in Laravel, die HTTP-Requests entgegennehmen und an entsprechende Controller weiterleiten.
- **Controllers**: Koordinieren den Datenfluss zwischen Client-Requests und Business Logic Services. Implementieren Input-Validierung und Response-Formatting.
- **Business Logic Services**: Kerngesch√§ftslogik f√ºr Kampagnenmanagement, Prospect-Import und Analytics. Kapseln komplexe Operationen und External API-Calls.

**Data Tier:**
- **MongoDB Database**: NoSQL-Datenbank f√ºr flexible Speicherung von Kampagnen, Prospects und Tracking-Daten. Unterst√ºtzt Schema-Evolution und horizontale Skalierung.
- **External APIs**: ERP-System f√ºr Kundendaten und K√ºba AG f√ºr Lead-Generierung. Bieten strukturierte Datenquellen f√ºr Prospect-Segmentierung.

### Integration mit Umsystemen

Die Architektur integriert folgende externe Systeme √ºber REST-APIs:

1. **ERP-System Integration**: √úber `ImportErpProspects` Action mit standardisiertem `ErpProspectData` DTO
2. **K√ºba AG API**: √úber `ImportKuebaProspects` Action mit `KuebaProspectData` DTO  
3. **Mailtrap Email Service**: F√ºr sicheren E-Mail-Versand und Testing √ºber SMTP/REST API
4. **Queue System**: F√ºr asynchrone Verarbeitung von E-Mail-Kampagnen und Datenimporten

### Begr√ºndung der Architekturwahl

**Skalierbarkeit**: Die drei-Tier Architektur erm√∂glicht unabh√§ngige Skalierung von Frontend, Backend und Datenbank je nach Lastanforderungen.

**Wartbarkeit**: Klare Trennung der Verantwortlichkeiten durch Schichten-Prinzip. Services kapseln Business Logic, Controllers handhaben HTTP-Kommunikation.

**Performance**: Stateless REST API erm√∂glicht horizontale Skalierung. MongoDB bietet optimierte Abfragen f√ºr Campaign Analytics.

üìö **Quellen**:
- _"Software Architecture Patterns" (Richards, 2015, O'Reilly)_
- [Laravel Architecture Concepts](https://laravel.com/docs/architecture)

---

## Aufgabe 3
Toolbasiertes Design und Dokumentation der APIs : BegruÃàndete Wahl der API Technologie sowie deren Dokumentations Tools. Vollst√§ndige Erstellung des API Designs fuÃàr die gem√§ss der Ausgangslage angebotene Web API. Dabei ist aber nur ein Datenobjekt vorzusehen.

### üéØ Ziel
Begr√ºndete Wahl der API-Technologie und Dokumentationstools sowie vollst√§ndige Erstellung des API-Designs f√ºr die Web API mit einem Datenobjekt.

### Gew√§hlte API-Technologie: REST mit OpenAPI 3.0

#### Begr√ºndung der API-Technologiewahl

**REST (Representational State Transfer)** wurde als API-Architektur gew√§hlt aufgrund folgender Vorteile:

- **Standardisierung**: HTTP-basiert mit etablierten Verben (GET, POST, PUT, DELETE)
- **Stateless**: Jeder Request ist unabh√§ngig, was horizontale Skalierung erm√∂glicht
- **Caching**: Unterst√ºtzt HTTP-Caching-Mechanismen f√ºr bessere Performance
- **Tooling**: Breite Unterst√ºtzung durch Entwicklungstools und Frameworks

#### Dokumentationstools

**OpenAPI 3.0 (YAML)** f√ºr API-Spezifikation:
- Maschinenlesbare Dokumentation erm√∂glicht automatische Code-Generierung
- Swagger UI f√ºr interaktive API-Dokumentation
- Unterst√ºtzung f√ºr Request/Response-Validierung

**Implementierte Tools**:
- **Swagger UI**: F√ºr interaktive API-Exploration und Testing
- **Postman Collection**: F√ºr automatisierte API-Tests
- **Laravel API Resources**: F√ºr konsistente JSON-Response-Struktur

### API-Design: Campaign Management API

Das API-Design fokussiert auf das **Campaign** Datenobjekt als zentrales Element:

#### OpenAPI 3.0 Spezifikation (YAML)
- [http://apde_be.test/api/docs/openapi/](http://apde_be.test/api/docs/openapi/)
- [http://localhost:8000/api/docs/openapi/](http://localhost:8000/api/docs/openapi/)

### Implementierungsdetails
**Laravel API Resources** sorgen f√ºr konsistente JSON-Responses:
```php
class CampaignResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'id' => $this->id,
            'title' => $this->title,
            'description' => $this->description,
            'status' => $this->status->value,
            'start_date' => $this->start_date?->toISOString(),
            'end_date' => $this->end_date?->toISOString(),
            'prospect_filter' => $this->prospect_filter,
            'created_at' => $this->created_at->toISOString(),
            'updated_at' => $this->updated_at->toISOString(),
            'landingpage' => new LandingpageResource($this->whenLoaded('landingpage')),
        ];
    }
}
```

### Begr√ºndung der Toolwahl

**OpenAPI 3.0**: Industriestandard f√ºr REST API-Dokumentation, erm√∂glicht automatische Validierung und Code-Generierung.

**Swagger UI**: Bietet interaktive Dokumentation, die von Entwicklern und Stakeholdern gleicherma√üen genutzt werden kann.

**Laravel Sanctum**: Leichtgewichtige Token-basierte Authentifizierung, optimal f√ºr SPA-Anwendungen.

üìö **Quellen**:
- _"REST API Design Rulebook" (Masse, 2011, O'Reilly)_
- [OpenAPI Specification 3.0](https://spec.openapis.org/oas/v3.0.3)

---

## Aufgabe 4
Auswahl einer geeigneten Entwicklungsumgebung unter begruÃàndeter BeruÃàcksichtigung der KI UnterstuÃàtzung.

## Form der Antwort
Die Struktur der Antwort muss sich an die Aufgabenstruktur halten und eine ent-sprechende Titelstruktur aufweisen.
Die geforderten Auswahlen sind jeweils mit einer fundierten Herleitung und mit mindestens je 2 Quellen (mind. je 1 aktuelles Fachbuch sowie je 1 Internetquelle) gut begruÃàndet darzulegen.
Jedes Element des geforderten Diagramms muss kurz (in 2-3 S√§tzen) beschrie-ben sein.
Das API-Design sollte in einem maschinenlesbaren Format (z.B. YAML) doku-mentiert werden, um eine einfache Integration und sp√§tere Erweiterungen zu erm√∂glichen.

## Hinweise
BeruÃàcksichtige fuÃàr den Technologie-Stack folgende Aspekte:
- Serverseitig: Middleware, Frameworks, Programmiersprache, Datenbank
- Clientseitig: Frameworks, Programmiersprache, Runtime U mgebungen

Die Softwarearchitektur muss folgende Aspekte abdecken:
- Server und Clientseitige Architektur mit deren Pakete und Komponenten
- Integration mit den Umsystemen uÃàber ad√§quate Schnittstellen

BeruÃàcksichtige fuÃàr die Entwicklungsumgebung Tools fuÃàr folgende Aspekte:
- UI Wireframing
- IDE
- Unit Testing
- API Testing
- KI UnterstuÃàtzung
- Versions kontrolle